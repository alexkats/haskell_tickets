* Ticket 1. Why FP and Haskell? 
** Основные идеи ФП:
- Сборка мусора
- Замыкания
- Вывод типов [[type inference]]
- Ленивая обработка (lazy evaluation) 
- Функции высшего поряда
** Статическая типизация
*** Деление языков
- Языки с статической типизацией
  * ФП :: Haskell, SML, OCaml, F#
  * ООП-императивные :: Java, C#, C++
- Языки с динамической типизацией
  * Python, Ruby, JavaScript, Erlang, Lisp

*** Преимущества статической типизации
+ Раннее обнаружение ошибок :: Ошибки находятся на этапе компиляции, а не выполнения. Часто программа на SML или Haskell работает правильно, как только ее наконец удается скомпилировать
+ Высокая поддерживаемость больших проектов :: Изменения могут быть верифицированы компилятором, и типы являются частью документации программы, облегчая ее понимание
+ Автоматизированная обработка программ :: Например, автоматический рефакторинг, как в средах IDEA или Eclipse
+ Оптимизация кода :: Код, написанный на статически типизированном языке, проще оптимизировать, так что в среднем статически типизированный язык эффективнее динамически типизированных
*** <<Type inference>>
Статические языки слишком многословны
#+BEGIN_SRC java
List<T> replicate(int n, T elem) {
    List<T> list = new ArrayList<T>(n);
    for (int i = 0; i < n; i++) {
        list.add(elem);
    }
    return list;
}
#+END_SRC
Но вывод типов позволяет не писать явные объявления типов - компилятор выводит их самостоятельно из контекста. 
#+BEGIN_SRC haskell
replicate 0 _ = []
replicate n elem = elem : replicate (n - 1) elem
#+END_SRC

** Конструкции Haskell
+ Ортогональность :: Язык состоит из небольшого числа независимых базовых конструкций, которые можно произвольно комбинировать между собой, получая сколь угодно сложные конструкции. В C нельзя возвращать массив из функций. В С++ многие возможности дублируются (функции/методы, указатели/ссылки). 
+ Замыкания (closures) :: Трудно реализовать в языках без сборки мусора типа C++.
+ Каррирование (currying) :: То же, что и для замыканий, плюс проблемы с перегрузкой функций по числу аргументов, как принято во многих императивных языках.
+ Вывод типов ([[type inference]]) :: Глобальный вывод типов накладывает серьезные ограничения на систему типов; Так, наличие наследования резко ослабляет возможности вывода типов.
+ Сопоставление с образцом (pattern matching) :: 
+ Классы типов (type classes) ::
** Сравнение императивных и функциональных языков
*** Изменяемое состояние (mutable state)
**** Проблема нелокальности (aliasing)
На один и тот же объект могут быть несколько ссылок. Если объект изменяемый, то изменение по одной ссылке приводит к изменениям по другим ссылкам. 
- Неправильная работа программы
- Долгая и сложная отладка ошибки
Для решения проблемы используется копирование объектов (*defensive copy*), но:
- Нужно знать, когда нужно копировать, а когда нет
- Копирование больших объектов может быть неэффективным

Проблема исчезает, если использовать *неизменяемые объекты* (*immutable objects*) :: все "изменяющие" методы возращают *новый* объект.
+ Не нужно копирование объектов
+ Современные сборщики мусора лучше заточены под большое количество объектов с малым сроком жизни, поэтому можно не бояться создавать новые объекты при вызове методов.
+ Aliasing для изменяемых данных создает проблемы при оптимизации кода, так как запись в память может приводить к изменению закэшированных в регистрах значений. Для неизменяемых данных aliasing не создает проблем.
**** Комбинаторная сложность и поддержаение инвариантов
Для значений полей объекта чаще всего должны выполняться условия корректности - *инварианты*. Каждый метод, изменяющий состояние объекта, должен проверять сохранения инварианта. 
В изменяемом объекте любой метод может изменить любое поле. Сложность работы по корректной поддержке инвариантов:
*[Количество полей] * [Количество методов]*

Для неизменяемых обхектов - *инварианты достаточно проверять только при создании объекта*.

**** Зависимость от истории 
Корректность состояния изменяемых объектов зависит от порядка вызова методов.
Если объект передается между разными модулями, которые ожидают определенной последовательности вызовов метода объекта. Это создает неявные связи между модулями, которые очень трудно тестировать и поддерживать.
*Для неизменяемых объектов опять же этой проблемы нет, так как объект никак не меняется при вызове его методов.*
**** Хранение объектов в коллекциях
#+BEGIN_SRC java
Point p = new Point(1, 2);
Set<Point> set = new HashSet<Point>();
set.add(p);
p.move(-1, 0);
boolean isInSet = set.contains(p); // может быть false
#+END_SRC
**** Многопоточный доступ
При доступе к изменяемым полям объекта одновременно из нескольких потоков требуется синхронизация, что является довольно неэффективной операцией. 
Для неизменяемых данных синхронизация не нужна, так как потоки только читают данные. 
Параллельные выисления в функциональных языках проще, так как:
+ Отсутствует необходимость расстановки блоков синхронизации, что упрощает программирование
+ Чистые функции всегда можно выполнять параллельно, так то не нужно задумываться над возможными побочными эффектами.
+ В Haskell с помощью монад можно проверять корректность параллелизации кода на этапе компиляции.
*** ООП
**** Наследование и изменяемость
#+BEGIN_SRC java
class Rectangle {
    private int w;
    private int h;
    Rectangle(int w, int h) {
        this.w = w; this.h = h;
    }
    void setWidth(int newW) { ... }
    void setHeight(int newH) { ... }
}
class Square extends Rectangle {
    Square(int side) {
        super(side, side);
    }
}
#+END_SRC
#+BEGIN_SRC java
void test(Rectangele rect) {
    rect.setWidth(5);
    rect.setHeight(4);
    assert(rect.getWidth() == 5 && rect.getHeight() == 4);
}
Square sq = new Square(3);
test(sq); // ???
#+END_SRC
Это нарушение *Liskov Substitution Principle*: Функция. которая принимает значения типа Т, должна также обрабатывать и значения любого подтипа Т.
Обратное наследование также является ошибочным:
#+BEGIN_SRC java
class Rectangle extends Square ...
void test(Square square) {
   int area = square.getSize() * square.getSize();
   assert(area == square.getArea());
}
Rectangle rect = new Rectangle(5, 3);
test(rect);
#+END_SRC
Единственное корректное решение - убрать методы set из Rectangle и Square, сделав их неизменяемыми.
**** Inheritance breaks encapsulation
Хотим посчитать, сколько раз в коллекцию добавлялся элемент.
#+BEGIN_SRC java
class CountingSet extends HashSet {
   private int count = 0;
   public boolean add(Object o) {
       count++;
       return super.add(o);
   }
   public boolean addAll(Collection c) {
       count += c.size();
       return super.addAll(c);
   }
}
#+END_SRC
*НО*:
#+BEGIN_SRC java
CountingSet set = new CountingSet();
set.addAll(Arrays.asList("1", "2", "3"));
// set.count == 6, хотя добавили 3 элемента!
#+END_SRC
Наследование реализации метода приводит к разным результатам в зависимости от реализации базового класса. Таким образом детали реализации прорываются через инкапсуляцию. 
Решение проблемы - использовать композицию классов (*favor composition over inheritance*).
**** Наследование и code reuse
#+ATTR_HTML: width = "100px"
#+ATTR_ORG: :width 100
[[./code_reuse_example.png]]
