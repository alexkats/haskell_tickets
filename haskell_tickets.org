* Ticket 1. Why FP and Haskell? 
** Основные идеи ФП:
- Сборка мусора :: появилась в LISP (1960)
- Замыкания :: появились в Scheme (1975) 
- Вывод типов ([[type inference]]) :: появился в ML (1979)
- Ленивая обработка ([[Ленивость][lazy evaluation]]) :: появилась в Miranda (1985)
- [[Функции высшего порядка]]
** Функции высшего порядка
Позволяют скоратить и упростить запись алгоритмов обработки данных в коллекциях, причем из этих функций легко строить целые "конвейеры" обработки данных. (map, fold, filter, etc)
#+BEGIN_SRC java
out = new int[in.length];
for  expresion(i = 0; i < in.length; i++) {
    out[i] = in[i] * 2;
}
#+END_SRC
#+BEGIN_SRC haskell
out = map (\x -> x * 2) in
-- то жone hour ago
Actions
22 февраля я вышел с учёбы и отправился в 30-часовой непрекращающийся трип-тусу. Ну и конечно после этого хотелось написать длиннющуе самое
out = map (*2) in
#+END_SRC
** Статическая типизация
*** Деление языков
- Языки с статической типизацией
  * ФП :: Haskell, SML, OCaml, F#
  * ООП-императивные :: Java, C#, C++
- Языки с динамической типизацией
  * Python, Ruby, JavaScript, Erlang, Lisp

*** Преимущества статической типизации
+ Раннее обнаружение ошибок :: Ошибки находятся на этапе компиляции, а не выполнения. Часто программа на SML или Haskell работает правильно, как только ее наконец удается скомпилировать
+ Высокая поддерживаемость больших проектов :: Изменения могут быть верифицированы компилятором, и типы являются частью документации программы, облегчая ее понимание
+ Автоматизированная обработка программ :: Например, автоматичесte	Ctrl + Q
H1	# Headingкий рефакторинг, как в средах IDEA или Eclipse
+ Оптимизация кода :: Код, написанный на статически типизированном языке, проще оптимизировать, так что в среднем статически типизированный язык эффективнее динамически типизированных
*** Type inference
Статические языки слишком многословны
#+BEGIN_SRC java
List<T> replicate(int n, T elem) {
    List<T> list = new ArrayList<T>(n);
    for (int i = 0; i < n; i++) {
        list.add(elem);
    }
    return list;
}
#+END_SRC
Но вывод типов позволяет не писать явные объявления типов - компи
Если же постоянно обнаруживается учащенный пульс – более 90 ударов в минуту – это может быть следствием вашего лятор выводит их самостоятельно из контекста. 
#+BEGIN_SRC haskell
replicate 0 _ = []
replicate n elem = elem : replicate (n - 1) elem
#+END_SRC

** Конструкции Haskell
+ Ортогональность :: Язык состоит из небольшого числа независимых базовых конструкций, которые можно произвольно комбинировать между собой, получая сколь угодно сложные конструкции. В C нельзя возвращать массив из функций. В С++ многие возможности дублируются (функции/методы, указатели/ссылки). 
+ Замыкания (closures) :: Трудно реализовать в языках без сборки мусора типа C++.
+ Каррирование (currying) :: То же, что и для замыканий, плюс проблемы с перегрузкой функций по числу аргументов, как принято во многих императивных языках.
+ Вывод типов ([[type inference]]) :: Глобальный вывод типов накладывает серьезные ограничения на систему типов; Так, наличие наследования резко ослабляет возможности вывода типов.
+ Сопоставление с образцом (pattern matching) :: 
+ Классы типов (type classes) ::
** Сравнение императивных и функциональных языков
*** Изменяемое состояние (mutable state)
**** Проблема нелокальности (aliasing)
На один и тот же объект могут быть несколько ссылок. Если объект изменяемый, то изменение по одной ссылке приводит к изменениям по другим ссылкам. 
- Неправильная работа программы
- Долгая и сложная отладка ошибки
Для решения проблемы используется копирование объектов (*defensive copy*), но:
- Нужно знать, когда нужно копировать, а когда нет
- Копирование больших объектов может быть неэффективным

Проблема исчезает, если использовать *неизменяемые объекты* (*immutable objects*) :: все "изменяющие" методы возращают *новый* объект.
+ Не нужно копирование объектов
+ Современные сборщики мусора лучше заточены под большое количество объектов с малым сроком жизни, поэтому можно не бояться создавать новые объекты при вызове методов.
+ Aliasing для изменяемых данных создает проблемы при оптимизации кода, так как запись в память может приводить к изменению закэшированных в регистрах значений. Для неизменяемых данных aliasing не создает проблем.
**** Комбинаторная сложность и поддержаение инвариантов
Для значений полей объекта чаще всего должны выполняться условия корректности - *инварианты*. Каждый метод, изменяющий состояние объекта, должен проверять сохранения инварианта. 
В изменяемом объекте любой метод может изменить любое поле. Сложность работы по корректной поддержке инвариантов:
*[Количество полей] * [Количество методов]*

Для неизменяемых обхектов - *инварианты достаточно проверять только при создании объекта*.

**** Зависимость от истории 
Корректность состояния изменяемых объектов зависит от порядка вызова методов.
Если объект передается между разными модулями, которые ожидают определенной последовательности вызовов метода объекта. Это создает неявные связи между модулями, которые очень трудно тестировать и поддерживать.
*Для неизменяемых объектов опять же этой проблемы нет, так как объект никак не меняется при вызове его методов.*
**** Хранение объектов в коллекциях
#+BEGIN_SRC java
Point p = new Point(1, 2);
Set<Point> set = new HashSet<Point>();
set.add(p);
p.move(-1, 0);
boolean isInSet = set.contains(p); // может быть false
#+END_SRC
**** Многопоточный доступ
При доступе к изменяемым полям объекта одновременно из нескольких потоков требуется синхронизация, что является довольно неэффективной операцией. 
Для неизменяемых данных синхронизация не нужна, так как потоки только читают данные. 
Параллельные вычисления в функциональных языках проще, так как:
+ Отсутствует необходимость расстановки блоков синхронизации, что упрощает программирование
+ Чистые функции всегда можно выполнять параллельно, так то не нужно задумываться над возможными побочными эффектами.
+ В Haskell с помощью монад можно проверять корректность параллелизации кода на этапе компиляции.
*** ООП
**** Наследование и изменяемость
#+BEGIN_SRC java
class Rectangle {
    private int w;
    private int h;
    Rectangle(int w, int h) {
        this.w = w; this.h = h;
    }
    void setWidth(int newW) { ... }
    void setHeight(int newH) { ... }
}
class Square extends Rectangle {
    Square(int side) {
        super(side, side);
    }
}
#+END_SRC
#+BEGIN_SRC java
void test(Rectangele rect) {
    rect.setWidth(5);
    rect.setHeight(4);
    assert(rect.getWidth() == 5 && rect.getHeight() == 4);
}
Square sq = new Square(3);
test(sq); // ???
#+END_SRC
Это нарушение *Liskov Substitution Principle*: Функция. которая принимает значения типа Т, должна также обрабатывать и значения любого подтипа Т.
Обратное наследование также является ошибочным:
#+BEGIN_SRC java
class Rectangle extends Square ...
void test(Square square) {
   int area = square.getSize() * square.getSize();
   assert(area == square.getArea());
}
Rectangle rect = new Rectangle(5, 3);
test(rect);
#+END_SRC
Единственное корректное решение - убрать методы set из Rectangle и Square, сделав их неизменяемыми.
**** Inheritance breaks encapsulation
Хотим посчитать, сколько раз в коллекцию добавлялся элемент.
#+BEGIN_SRC java
class CountingSet extends HashSet {
   private int count = 0;
   public boolean add(Object o) {
       count++;
       return super.add(o);
   }
   public boolean addAll(Collection c) {
       count += c.size();
       return super.addAll(c);
   }
}
#+END_SRC
*НО*:
#+BEGIN_SRC java
CountingSet set = new CountingSet();
set.addAll(Arrays.asList("1", "2", "3"));
// set.count == 6, хотя добавили 3 элемента!
#+END_SRC
Наследование реализации метода приводит к разным результатам в зависимости от реализации базового класса. Таким образом детали реализации прорываются через инкапсуляцию. 
Решение проблемы - использовать композицию классов (*favor composition over inheritance*).
**** Наследование и code reuse
#+ATTR_HTML: width = "100px"
#+ATTR_ORG: :width 100
[[./images/code_reuse_example.png]]
Хотим использовать класс XUsefulShape из проекта X в проекте Y. Варианты действий:
1) Перенести всю иерархию X в проект Y (при этом, возможно, часть функциональности будет дублироваться)
2) Создать класс YUsefulShape, как копию XUsefulShape с точностью до замены X на Y.
Таким образом, глубокие иерархии классов снижают code reuse. *Favor composition over inheritance*

Для того, чтобы ООП не создавало проблем, структура классов должна удовлетворять следующим свойствам:
1) Объекты должны быть по возможности неизменяемыми
2) Иерархии наследования не должны быть глубокими
3) Наследование реализации и переопределение методов использовать не нужно. 

*Algebraic data types*
ADT = OOP done right
ООП:
#+BEGIN_SRC java
abstract class Shape ...
class Circle extends Shape ...
class Rectangle extends Shape ...
class ComplexShape extends Shape ...
#+END_SRC
ADT:
#+BEGIN_SRC haskell
data Shape = Circle | Rectangle | ComplexShape
#+END_SRC
В ООП методы группируются по классам - в [[Algebraic Data Types][ADT]] подклассы группируются по методам (функциям).
[[./images/oop_adt.png]]
Из-за этого в ООП легко добавлять новые классы, не меняя код других классов; в ADT легко добавлять новые функции, не меняя код остальных функций. 
** Сравнение Haskell и других функциональных языков
<<<<<<< Updated upstream
*** Языки семейства ML
Standard ML, OCaml, F#
*Основные отличия от Haskell*:
- строгие вычисления вместо ленивых
- возможность написания не-чисто функциональных программ (наличие изменяемых данных и исключений)
  * возможность писать программы в императивном стиле
- отсутствие типов классов
- более продвинутая система модулей

Семейство ML-подобных языков создавалось в основном в 80-е - начале 90-х годов.
+ языки и реализации стабильные и зрелые, пригодны для промышленного использования.
- вышли из моды; интерес исследователей перешел к Haskell
- слабая поддержка многопоточности
- исследователи ФП в 80-е имели недостаточно опыта => стандартная библиотека SML/OCaml страдает непоследовательностью
- отсутствие классов типов приводит к необходимости иметь разные функции для разных типов. (в OCaml есть + для сложения целых чисел и +. для сложения вещественных)
*** Функциональная чистота 
Функция является *чистой*, если ее значение зависит только от значений входных параметров. 
Наличие в языке переменных противоречит чистоте. 
Важным для функциональных программ является свойство *referential transparency* (прозрачность по ссылкам). Вместо ссылки на функцию можно подставить ее определение:
#+BEGIN_SRC haskell
twice x = x + x
test = twice 10
-- эквивалентно:
test = 10 + 10
#+END_SRC
Referential transparency позволяет компилятору уменьшить количество промежуточных объектов при работе со списками и другими структурами данных. 
Плюсы функциональной чистоты:
+ бОльшие возможности для оптимизации
+ облегчение понимания и отладки программы; отлаживать функцию можно независимо от остальной программы
+ чистые функции проще объединять в композиции, так как между ними нет неявных связей в виде изменяемого состояния
+ чисто функциональные программы проще сделать параллельными; чистая функция всегда является thread-safe
Минусы:
- трудности при взаимодействии с внешним миром (I/O). В Haskell решается через монады:
  - монады в силу "вирусной" природы наинают загромождать всю программу
  - в случае повсеместного использования монады IO мы делаем программу императивной
- некоторые алгоритмы и структуры данных (массивы, хеш-таблицы) не имеют чисто-функциональных аналогов по эффективности.
*** Ленивость
- Строгие вычисления :: перед вызовом функции значения ее аргументов вычисляются (call-by-value)
#+BEGIN_SRC

f x y = y
f (1+2) (3+4)
-> f 3 7
-> 7
#+END_SRC
- Ленивые вычисления :: значения аргументов не вычисляются, аргументы передаются в виде невычисленных thunk'ов, которые форсируются по мере необходимости (call-by-need):
#+BEGIN_SRC
f x y = y
f (1+2) (3+4)
-> (3+4)
-> 7
#+END_SRC
Ленивый язык обязан быть чистым. 
+ можно присваивать значения в любом порядке, т.к. при ленивых вычислениях вычисление значения произойдет только при его использовании
+ можно использовать бесконечные СД; можно манипулировать ими так же, как и обычными - главное. чтобы никогда не вычислялся весь список целиком

Потребление памяти программой на Haskell может быть очень трудно предсказуемым. В Haskell есть дополнительные аннотации строгости.

Существует промежуточная стратегия вычислений - *lenient evaluation* (расслабленные вычисления), при которой аргументы вычисляются параллельно вычислению функции. 

Большинство мнений в ФП-сообществе считает, что повышения выразительности языка недостаточно велико по сравнению с проблемами поиска утечек памяти, так что лучше опциональная ленивость или lenient evaluation.

*** Идеальный функциональный язык
+ чистота по умолчанию с возможностью явно указывать возможные побочные эффекты функции
+ строгость по умолчанию с удобной опциональной ленивостью
** Возможные вопросы к билету
*** Перечислите основные парадигмы ФП и Haskell, отличительные особенности
1. FP: 
   1. Иммутабельность
   2. Чистота
   3. Статическая типизация и вывод типов
   4. Функции высшего порядка
2. Haskell:
   1. Ленивые вычисления
   2. Pattern matching
   3. Type classes
*** Укажите преимущества чистоты
1. Есть referential transparency \Rightarrow есть бОльшие возможности для оптимизации
2. Проще делить программу на независимые модули и отлаживать их по отдельности (\approx один модуль - одна функция) 
3. Чистые фукнции проще объединять в композиции, так как между ними нет неявных связей в виде изменяемого состояния
4. Чисто функциональные программы проще сделать параллельными
*** Укажите преимущества ленивых вычислений
1. Можно присваивать значения в любом порядке, так как при ленивых вычислениях вычисление значения произойдет только при его использовании
2. Можно использовать бесконечные структуры данных
3. Ленивый язык более выразительный, чем строгий
4. Иногда можно улучшить эффективность использования памяти при ленивых вычислениях.
*** Укажите преимущества иммутабельности
1. Нет проблемы нелокальности: изменение по одной ссылке не приведет к изменениям по остальным ссылкам, так как "изменяющая" функция вернет новый объект
2. Нет необходимости в копировании объектов
3. Инварианты достаточно проверять только при создании объекта
4. Нет зависимости от истории \Rightarrow нет зависимости от порядка вызова методов
5. Безопасное хранение объекта в коллекции
6. Не требуется синхронизация, так как все потоки только читают данные

* Ticket 2: Basic syntax
  
Инструкции (statement) в императивных языках в Haskell являются выражениями (expression).
** Функции   
*** Объявить функцию
#+BEGIN_SRC haskell
  fun :: argType (-> argType)* -> resType
#+END_SRC

*** Определить функцию
#+BEGIN_SRC haskell
  fun arg1 arg2 argN = smth
#+END_SRC

*** Вызов функции
#+BEGIN_SRC haskell
  fun arg1 arg2 argN
#+END_SRC

** Параметрический полиморфизм
#+BEGIN_SRC haskell
  fun :: argType (-> argType)* -> resType
  id  :: a -> a 
#+END_SRC
*Параметрический полиморфизм* - когда тип результата содержит одну или более
(не связанных) /переменных типа/, так что значение может принимать любой тип,
который получится от подстановки вместо этой переменной конкретного типа.

*Ad-hoc полиморфизм* - когда результат может иметь различные типы, потому что
для каждого типа дано свое определение (оператор + как пример).
** Базовый синтаксис (?)
*** Списки
[type]; конкатенация: ++ и l1:l2; String ~ [Char]  
head, tail, last, init, drop, take, replicate
zip/unzip/zipWith
l !! i - элемент по номеру, работает за линию

*** Лямбды 
#+BEGIN_SRC haskell
  \x -> x * x
#+END_SRC

*** let и where
~let~ bindings ~in~ expression
expresion ~where~ bindings

*** if
~if~ predicate ~then~ expression if true ~else~ expression if false

*** guards
#+BEGIN_SRC haskell
  fun x
      | predicate1
      | predicate2
      | …
      | otherwise (задефайнена как True)
#+END_SRC

*** case
#+BEGIN_SRC haskell
  fun x = case x of
      0 -> “a”
      1 -> “b”
      _ -> “e”
#+END_SRC

** Еще функции
*** Функции высшего порядка
#+BEGIN_SRC haskell
  apply :: Int -> Int -> (Int -> Int -> Int) -> Int
  apply a b f = f a b

  map    :: (a -> b) -> [a] -> [b]
  filter    :: (a -> Bool) -> [a] -> [a]
  foldr1  :: (a -> a -> a) -> [a] ->  a
#+END_SRC

Отличие foldr от foldr1 в том, что аккумулятором берется первый элемент
 списка (выпадет в рантайме на пустом списке!)
scanl/scanr - как foldl/foldr, только возвращают список всех промежуточных результатов

#+BEGIN_SRC haskell
  span   :: (a -> Bool)   -> [a] -> ([a], [a])

  uncurry :: (a -> b -> c) -> (a, b) -> c
  uncurry f (x, y) = f x y
#+END_SRC

*** Частичное применение функций:
(реальный тип `Int -> (Int -> Int)`)
#+BEGIN_SRC haskell
  sum :: Int -> Int -> Int  
  sum x y = x + y
#+END_SRC

*** flip
#+BEGIN_SRC haskell
  flip :: (a -> b -> c) -> b -> a -> c
  flip f b a = f a b
#+END_SRC

*** Pattern matching
#+BEGIN_SRC haskell
  fact :: Integer -> Integer
  fact 0 = 1
  fact n = n * fact (n - 1)
#+END_SRC

*** Композиция функций
#+BEGIN_SRC haskell
  infixr 9 .
  (.) :: (b -> c) -> (a -> b) -> a -> c -- композиция функций
  f . g = \x -> f (g x)

  infixr 0 $
  ($) :: (a -> b) -> a -> b  -- применение функции
  f $ x = f x
#+END_SRC
Понимать $ как “дальше следует последний аргумент к этой функции”
Применение можно само по себе рассматривать как функцию (в духе map ($ 3) [(+1), odd, even])

Point-free стиль: фокусирует внимание на функциях, а не на манипуляциях с данными
 (каррирование + композиция. Point здесь - “точка” не как знак композиции, а в смысле топологии)

** Всякое
*** Range
#+BEGIN_SRC haskell
  [0 .. 5]     -- [0, 1, 2, 3, 4, 5]
  [0, 2 .. 5]  -- [0, 2, 4]
  [0..]        -- [0, 1, 2, 3, ...] : бесконечный список
  [0, 2 ..]    -- [0, 2, 4, 6, ...] : все четные числа
  [5, 4 .. 1]  -- [5, 4, 3, 2, 1]
#+END_SRC

*** List comprehension
#+BEGIN_SRC haskell
  [x | x <- [1..10], even x]  -- [2, 4, 6, 8, 10]
  [x * y | x <- [1, 3, 5], y <- [2, 4, 6], x * y >= 10]  -- [12, 18, 10, 20, 30]
#+END_SRC

* Ticket 3. Datas, Classes, Instances
** Types, Type variables, Type aliases
*** Types
У всего в Haskell есть тип.
Базовые типы: Char, Bool, Int, Integer, Float, ...
*** Type variables
#+BEGIN_SRC haskell
head :: [a] -> a
fst :: (a, b) -> a
#+END_SRC
Функции, которые имеют переменные типов, называются *полиморфными функциями*.
*** Type aliases
#+BEGIN_SRC haskell
type BinaryIntFunction = Int -> Int -> Int
type String            = [Char]
type PairList a b      = [(a, b)]
#+END_SRC
В Java такого нет. В C++:
#+BEGIN_SRC c++
typedef std::fucntion<int(int int)> binary_int_fucntion;
#define int_vector std::vector<int>
using str = std::string;
#+END_SRC
** Algebraic Data Types
*** Тип-сумма
ST = T_1 + T_2 + ... + T_n
Java (special case): 
#+BEGIN_SRC java
public enum TrafficLight {
    RED, YELLOW, GREEN, BLUE
}
#+END_SRC 
C++ (also a special case):
#+BEGIN_SRC c++ 
union primitive_mess {
    long x;
    double y;
};
#+END_SRC
*** Тип-произведение
PT = T_1 \times T_2 \times ... \times T_n
C++:
#+BEGIN_SRC c++
// user = int \times string \times string
struct user {
    int uid;
    string login;
    striin pass;
};
#+END_SRC
*** ADT
T ::= Int | Char | Double | ...
ADT ::= T | ADT + ADT | ADT \times ADT
**** Enums 
#+BEGIN_SRC haskell 
data TrafficLight = Red | Yellow | Green | Blue
lightName :: TrafficLight -> String
lightName Red    = "red"
lightName Yellow = "yellow"
-- ...
#+END_SRC
Например, Bool является примером enumeration.
**** Structures
#+BEGIN_SRC haskell
data User = User Int String String
getUid :: User -> Int
getUid (User uid _ _) = uid
-- ...
#+END_SRC
**** Parametric
#+BEGIN_SRC haskell
data Vector a = Vector2D a a | Vector3D a a a
packVector :: Vector a -> [a]
packVector (Vector2D x y)   = [x, y]
packVector (Vector3D x y z) = [x, y, z]

vecLen :: Vector Double -> Double
vecLen = sqrt . sum . map (^2) . packVector
#+END_SRC
***** Maybe
#+BEGIN_SRC haskell
data Maybe a = Nothing | Just a
#+END_SRC 
***** Either
#+BEGIN_SRC haskell
data Either a b = Left a | Right b
-- Left - обычно ошибка, Right - получившееся значение
#+END_SRC 
**** Recursive
#+BEGIN_SRC haskell
data List a = Nil | Cons a (List a)
data [] a   = []  | a : [a]
#+END_SRC 
*** Record Syntax
#+BEGIN_SRC haskell
data User = User
    { uid      :: Int
    , login    :: String
    , password :: String
    }
-- не более чем синтаксический сахар для этого:
data User = User Int String String

uid :: User -> Int
uid (User i _ _) = i

login :: User -> String
login (User _ l _) = l

password :: User -> String
password (User _ _ p) = p
#+END_SRC
**** Record field patterns
#+BEGIN_SRC haskell
isIvan :: User -> BOOL
isIvan User { login = userName } = userName == "Ivan"
-- или
isIvan User { login = "Ivan" } = True
isIvan _                       = False
#+END_SRC
**** Record update syntax
#+BEGIN_SRC haskell 
cloneIvan :: User
cloneIvan = ivan { uid = 2 }
#+END_SRC
**** Duplicate Record Fields? 
#+BEGIN_SRC haskell
data User  = User  { uid :: Int, login :: String }
data Admin = Admin { aid :: Int, login :: String }
login :: ???
-- ограничение на названия полей
-- обходится в GHC 8 c DuplicateRecordFiled
data Person 
    = User  { uid   :: Int,    login :: String } 
    | Admin { login :: String, aid   :: Int    }
login :: Person -> String  -- real implementation
login (User  _ l) = l
login (Admin l _) = l
#+END_SRC
** Type Classes
*** Ad hoc polymorphis
Ad-hoc \equiv "for this", "for this specific purpose"
*Ad hoc polymorphism* is a kind of polymorphism in which polymorphic functions can be applied to arguments of different types, because a polymorphic function can denote a number of distinct and potentially heterogeneous implementations depending on the type of argument(s) to which it is applied. It is also known as function overloading or operator overloading. The term ad hoc in this context is not intended to be pejorative; it refers simply to the fact that this type of polymorphism is not a fundamental feature of the type system. (/from wikipedia/)
#+BEGIN_SRC haskell
class Printable p where
    printMe :: p -> String

data Foo = Foo

instance Printable Foo where
    printMe Foo = "Foo"
#+END_SRC
В Java - интерфейсы.
*** Multiple constraints
#+BEGIN_SRC haskell 
class I a where
    measure :: a -> Int -> Double

class J a where
    getParameter :: a -> Int

doMeasure :: (I a, J a) => a -> Double
doMeasure obj = measure obj $ getParameter obj
#+END_SRC
В Java:
#+BEGIN_SRC java 
public <T extends I & J> doubleDoMeasure(T obj) { ... }
#+END_SRC
*** Standard Type classes
**** Eq
Used for types that support _equality_ testing. The functions its members implement are (==) and (/=).
**** Ord
Used for type that have an _ordering_. Functions: (>), (<), (>=), (<=).
Ord \subset Eq.
#+BEGIN_SRC haskell
data Ordering = LT | EQ | GT
-- simplified version of Ord class
class Eq a => Ord a where
   compare              :: a -> a -> Ordering
   (<), (<=), (>=), (>) :: a -> a -> Bool

   compare x y
        | x == y    =  EQ
        | x <= y    =  LT
        | otherwise =  GT

   x <= y           =  compare x y /= GT
   x <  y           =  compare x y == LT
   x >= y           =  compare x y /= LT
   x >  y           =  compare x y == GT
#+END_SRC
**** Show
Members of this type class can be presented as _strings_.
**** Read
The ~read~ function _takes a string and returns a type_ which is a member of ~Read~.
**** Enum
Enum members are _sequentially ordered types_ - they can be enumerated. 
{(), Bool, Char, Ordering, Int, Integer, Float, Double} \subset Enum
**** Bounded
Bounded members have _an upper and a lower bound_.
{Int, Char, Bool, ()} \subset Bounded
**** Num
Its members have the property of being able to act like _numbers_.
{Int, Integer, Float, Double} \subset Num
**** Integral
Includes only integral (_whole_) numbers: Int and Integer
**** Floating
Includes only _floating point_ numbers: Float and Double.
*** deriving
#+BEGIN_SRC haskell
data TrafficLight = Red | Yellow | Green | Blue
    deriving (Eq, Ord, Enum, Bounded, Show, Read)
#+END_SRC 
*** DatatypeContexts
(It's better not to use it)
#+BEGIN_SRC haskell
data (Ord a) => OrderedList a = Nil | Node { value :: a, next :: OrderedList a }
-- we want
insert :: a -> OrderedList a -> OrderedList a
-- but we can't
#+END_SRC 
** Возможные вопросы к билету
*** Напишите, что такое DatatypeContexts? Приведите пример (не из презентации)
Ограничения на параметры в объявлениях ~data~ и ~newtype~. Объявленные таким образом типы требуют выполнения ограничений при создании (/construction/) и деконструкции (/deconstruction/, \approx разбиение конструктора при паттерн-матчинге), даже если эти ограничения неиспользуются. (deprecated in Haskell 7.2)
#+BEGIN_SRC haskell
data Eq a => Foo a = Constr a

-- не можем написать функцию:
isEq :: Foo a -> Foo a -> Bool
-- должны написать:
isEq :: Eq a => Foo a -> Foo a -> Bool
isRa (Constr x) (Constr y) = x == y

-- не сработает:
getVal :: Foo a -> a
-- сработает:
getVal :: Eq a => Foo a -> a
getVal (Constr x) = x
#+END_SRC
*** Напишите тип следующей функции в наиболее общем виде: ~f a = map (* a) . map (uncurry (+)) . map (\x -> (x, x))~
#+BEGIN_SRC haskell 
f :: Num a => a -> [a] -> [a]
#+END_SRC
*** Напишите функцию с типом, которая принимает список пар чисел и оставляет только такие, что сумма чисел в паре четная. 
#+BEGIN_SRC haskell
evenPairs :: (Integral a) :: [(a, a)] -> [(a, a)]
evenPairs = filter (even . uncurry (+))
#+END_SRC 
*** Задан тип данных ~data Role a = A { name :: String, role :: a } | B { name :: String, roles :: [a] }~. Напишите конструкцию, синтаксическим сахаром для которой является данных Record Syntax.
#+BEGIN_SRC haskell
data Role a = A String a | B String [a]
#+END_SRC

* Ticket 4: Kinda Monoids

*** Record syntax
#+BEGIN_SRC haskell
  data Person = Person { firstName :: String  
                       , lastName :: String  
                       , age :: Int  
                       , height :: Float  
                       , phoneNumber :: String  
                       , flavor :: String  
                       } deriving (Show)   

--Record field patterns
isIvan :: User -> Bool
isIvan User { login = userName } = userName == "Ivan"

--Record update syntax
cloneIvan :: User
cloneIvan = ivan { uid = 2 }  -- User 2 "Ivan" "123"
#+END_SRC

* Ticket 5. Monads, part 1
** Объяснение на коробках 
[[./images/monad_box.png]]
** Определение
*Переменная* - контейнер для /данных/
*Монада* - контейнер для /вычисления/
Монады применяют функции, которые возвращают завернутые значения, к завернутому знаению.
#+BEGIN_SRC haskell
class Monad m where   -- m :: * -> *
    return :: a -> m a                  -- return
    (>>=)  :: m a -> (a -> m b) -> m b  -- bind
    (>>)   :: m a -> m b -> m b         -- then
    m >> k = m >>= \_ -> k
(=<<) :: Monad m => (a -> m b) -> m a -> m b
f =<< x = x >>= f
infixl 1  >>, >>=
infixr 1  =<<
#+END_SRC 
*Свойства монад*:
#+BEGIN_SRC haskell
return a >>= f  ≡ f a                      -- left identity
m >>= return    ≡ m                        -- right identity
(m >>= f) >>= g ≡ m >>= (\x -> f x >>= g)  -- associativity
#+END_SRC
** Базовые монады
*** Maybe
#+BEGIN_SRC haskell
data Maybe a = Nothing | Just a

instance Monad Maybe where
    return = Just
  
    Nothing >>= _ = Nothing
    Just a  >>= f = f a
#+END_SRC 
*** Identity
#+BEGIN_SRC haskell
newtype Identity a = Identity { runIdentity :: a }
instance Monad Identity where
    return  = Identity
    i >>= f = ...
#+END_SRC
*** Either
#+BEGIN_SRC haskell
data Either a b = Left a | Right b
instance Monad (Either e) where
    return = Right
    Right m >>= k = k m
    Left e  >>= _ = Left e
#+END_SRC
*** List
#+BEGIN_SRC haskell
instance Monad [] where
    return x = [x]
    l >>= f  = concat (map f l) -- or using concatMap
#+END_SRC
** Monad composition
#+BEGIN_SRC haskell
(.)   ::            (b ->   c) -> (a ->   b) -> a ->   c
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c

m >>= (f >=> g) ≡ m >>= f >>= g
m >>= (f <=< g) ≡ m >>= g >>= f

(f >=> g) >=> h ≡ f >=> (g >=> h)    -- associativity
#+END_SRC
** Joining monads
#+BEGIN_SRC haskell
join :: Monad m => m (m a) -> m a
#+END_SRC
К сожалению, нельзя сделать функцию ~extract~, которая работала бы для всех монад, так как комбинация основных функций монады не дает такой возможности. Чтобы вытаскивать значение, нужно знать больше информации о виде конкретной монады. Например, у ~Identity~ есть функция ~runIdentity~. 
#+BEGIN_SRC haskell 
extract :: Monad m => m a -> a
#+END_SRC
** Функции для монад
*Control.Monad*:
#+BEGIN_SRC haskell
liftM    :: Monad m => (a -> b) -> m a -> m b
liftM2   :: Monad m => (a -> b -> c) -> m a -> m b -> m c
#+END_SRC
*Control.Monad.Extra*:
#+BEGIN_SRC haskell
ifM   :: Monad m => m Bool -> m a -> m a -> m a
(||^) :: Monad m => m Bool -> m Bool -> m Bool
#+END_SRC
** Возможные вопросы к билету
*** Что такое монада?
Монады применяют функции, которые возвращают завернутые значения, к завернутому знаению.
#+BEGIN_SRC haskell
class Monad m where   -- m :: * -> *
    return :: a -> m a                  -- return
    (>>=)  :: m a -> (a -> m b) -> m b  -- bind
    (>>)   :: m a -> m b -> m b         -- then
    m >> k = m >>= \_ -> k
(=<<) :: Monad m => (a -> m b) -> m a -> m b
f =<< x = x >>= f
infixl 1  >>, >>=
infixr 1  =<<
#+END_SRC 
*** Напишите реализацию Monad для Maybe
#+BEGIN_SRC haskell
data Maybe a = Nothing | Just a

instance Monad Maybe where
    return = Just
    Nothing >>= _ = Nothing
    Just a  >>= f = f a
#+END_SRC 
*** Напишите не меньше пяти типов данных, являющихся монадой
1. []
2. Maybe
3. Either
4. IO
5. State
6. Identity
7. Writer
8. Reader
9. RWS
10. Cont
*** Напишите не менее семи функций, полезных при работе с монадами
1. return
2. >>=
3. =<<
4. >>
5. liftM
6. liftM2
7. >=>
8. <=<
9. join
10. ifM
11. (||^)
* Ticket 7. Monads, part 2
** Writer monad
Хотим вести лог вычислений.
#+BEGIN_SRC haskell
binPow :: Int -> Int -> Int
binPow 0 _      = 1
binPow n a
    | even n    = let b = binPow (n `div` 2) a in b * b
    | otherwise = a * binPow (n - 1) a
type IntWithLog = (Int, String)

binPow :: Int -> Int -> IntWithLog
binPow 0 _      = (1, "")
binPow n a
    | even n    = let (b, msg) = binPow (n `div` 2) a 
                  in (b * b, msg ++ "Square " ++ show b ++ "\n")
    | otherwise = let (b, msg) = binPow (n - 1) a
                  in (a * b, msg ++ "Mul " ++ show a ++ " and " ++ show b ++ "\n")
#+END_SRC
#+BEGIN_SRC haskell
newtype Writer w a = Writer { runWriter :: (a, w) } -- a is value, w is log

instance Monoid w => Monad (Writer w) where
    return a            = Writer (a, mempty)
    Writer (x, v) >>= f = let Writer (y, v') = f x
                          in Writer (y, v `mappend` v')

tell       :: w -> Writer w ()
execWriter :: Writer w a -> w
writer     :: (a, w) -> Writer w a
#+END_SRC
