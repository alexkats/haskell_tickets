* Ticket 1: Intro. Why FP and Haskell? 
** Основные идеи ФП:
- Сборка мусора :: появилась в LISP (1960)
- Замыкания :: появились в Scheme (1975) 
- Вывод типов ([[type inference]]) :: появился в ML (1979)
- Ленивая обработка ([[Ленивость][lazy evaluation]]) :: появилась в Miranda (1985)
- [[Функции высшего порядка]]
** Функции высшего порядка
Позволяют скоратить и упростить запись алгоритмов обработки данных в коллекциях, причем из этих функций легко строить целые "конвейеры" обработки данных. (map, fold, filter, etc)
#+BEGIN_SRC java
out = new int[in.length];
for  expresion(i = 0; i < in.length; i++) {
    out[i] = in[i] * 2;
}
#+END_SRC
#+BEGIN_SRC haskell
out = map (\x -> x * 2) in
-- то же самое
out = map (*2) in
#+END_SRC
** Статическая типизация
*** Деление языков
- Языки с статической типизацией
  * ФП :: Haskell, SML, OCaml, F#
  * ООП-императивные :: Java, C#, C++
- Языки с динамической типизацией
  * Python, Ruby, JavaScript, Erlang, Lisp

*** Преимущества статической типизации
+ Раннее обнаружение ошибок :: Ошибки находятся на этапе компиляции, а не выполнения. Часто программа на SML или Haskell работает правильно, как только ее наконец удается скомпилировать
+ Высокая поддерживаемость больших проектов :: Изменения могут быть верифицированы компилятором, и типы являются частью документации программы, облегчая ее понимание
+ Автоматизированная обработка программ :: Например, автоматический рефакторинг, как в средах IDEA или Eclipse
+ Оптимизация кода :: Код, написанный на статически типизированном языке, проще оптимизировать, так что в среднем статически типизированный язык эффективнее динамически типизированных
*** Type inference
Статические языки слишком многословны
#+BEGIN_SRC java
List<T> replicate(int n, T elem) {
    List<T> list = new ArrayList<T>(n);
    for (int i = 0; i < n; i++) {
        list.add(elem);
    }
    return list;
}
#+END_SRC
Но вывод типов позволяет не писать явные объявления типов - компилятор выводит их самостоятельно из контекста. 
#+BEGIN_SRC haskell
replicate 0 _ = []
replicate n elem = elem : replicate (n - 1) elem
#+END_SRC

** Конструкции Haskell
+ Ортогональность :: Язык состоит из небольшого числа независимых базовых конструкций, которые можно произвольно комбинировать между собой, получая сколь угодно сложные конструкции. В C нельзя возвращать массив из функций. В С++ многие возможности дублируются (функции/методы, указатели/ссылки). 
+ Замыкания (closures) :: Трудно реализовать в языках без сборки мусора типа C++.
+ Каррирование (currying) :: То же, что и для замыканий, плюс проблемы с перегрузкой функций по числу аргументов, как принято во многих императивных языках.
+ Вывод типов ([[type inference]]) :: Глобальный вывод типов накладывает серьезные ограничения на систему типов; Так, наличие наследования резко ослабляет возможности вывода типов.
+ Сопоставление с образцом (pattern matching) :: 
+ Классы типов (type classes) ::
** Сравнение императивных и функциональных языков
*** Изменяемое состояние (mutable state)
**** Проблема нелокальности (aliasing)
На один и тот же объект могут быть несколько ссылок. Если объект изменяемый, то изменение по одной ссылке приводит к изменениям по другим ссылкам. 
- Неправильная работа программы
- Долгая и сложная отладка ошибки
Для решения проблемы используется копирование объектов (*defensive copy*), но:
- Нужно знать, когда нужно копировать, а когда нет
- Копирование больших объектов может быть неэффективным

Проблема исчезает, если использовать *неизменяемые объекты* (*immutable objects*) :: все "изменяющие" методы возращают *новый* объект.
+ Не нужно копирование объектов
+ Современные сборщики мусора лучше заточены под большое количество объектов с малым сроком жизни, поэтому можно не бояться создавать новые объекты при вызове методов.
+ Aliasing для изменяемых данных создает проблемы при оптимизации кода, так как запись в память может приводить к изменению закэшированных в регистрах значений. Для неизменяемых данных aliasing не создает проблем.
**** Комбинаторная сложность и поддержаение инвариантов
Для значений полей объекта чаще всего должны выполняться условия корректности - *инварианты*. Каждый метод, изменяющий состояние объекта, должен проверять сохранения инварианта. 
В изменяемом объекте любой метод может изменить любое поле. Сложность работы по корректной поддержке инвариантов:
*[Количество полей] * [Количество методов]*

Для неизменяемых обхектов - *инварианты достаточно проверять только при создании объекта*.

**** Зависимость от истории 
Корректность состояния изменяемых объектов зависит от порядка вызова методов.
Если объект передается между разными модулями, которые ожидают определенной последовательности вызовов метода объекта. Это создает неявные связи между модулями, которые очень трудно тестировать и поддерживать.
*Для неизменяемых объектов опять же этой проблемы нет, так как объект никак не меняется при вызове его методов.*
**** Хранение объектов в коллекциях
#+BEGIN_SRC java
Point p = new Point(1, 2);
Set<Point> set = new HashSet<Point>();
set.add(p);
p.move(-1, 0);
boolean isInSet = set.contains(p); // может быть false
#+END_SRC
**** Многопоточный доступ
При доступе к изменяемым полям объекта одновременно из нескольких потоков требуется синхронизация, что является довольно неэффективной операцией. 
Для неизменяемых данных синхронизация не нужна, так как потоки только читают данные. 
Параллельные вычисления в функциональных языках проще, так как:
+ Отсутствует необходимость расстановки блоков синхронизации, что упрощает программирование
+ Чистые функции всегда можно выполнять параллельно, так то не нужно задумываться над возможными побочными эффектами.
+ В Haskell с помощью монад можно проверять корректность параллелизации кода на этапе компиляции.
*** ООП
**** Наследование и изменяемость
#+BEGIN_SRC java
class Rectangle {
    private int w;
    private int h;
    Rectangle(int w, int h) {
        this.w = w; this.h = h;
    }
    void setWidth(int newW) { ... }
    void setHeight(int newH) { ... }
}
class Square extends Rectangle {
    Square(int side) {
        super(side, side);
    }
}
#+END_SRC
#+BEGIN_SRC java
void test(Rectangele rect) {
    rect.setWidth(5);
    rect.setHeight(4);
    assert(rect.getWidth() == 5 && rect.getHeight() == 4);
}
Square sq = new Square(3);
test(sq); // ???
#+END_SRC
Это нарушение *Liskov Substitution Principle*: Функция. которая принимает значения типа Т, должна также обрабатывать и значения любого подтипа Т.
Обратное наследование также является ошибочным:
#+BEGIN_SRC java
class Rectangle extends Square ...
void test(Square square) {
   int area = square.getSize() * square.getSize();
   assert(area == square.getArea());
}
Rectangle rect = new Rectangle(5, 3);
test(rect);
#+END_SRC
Единственное корректное решение - убрать методы set из Rectangle и Square, сделав их неизменяемыми.
**** Inheritance breaks encapsulation
Хотим посчитать, сколько раз в коллекцию добавлялся элемент.
#+BEGIN_SRC java
class CountingSet extends HashSet {
   private int count = 0;
   public boolean add(Object o) {
       count++;
       return super.add(o);
   }
   public boolean addAll(Collection c) {
       count += c.size();
       return super.addAll(c);
   }
}
#+END_SRC
*НО*:
#+BEGIN_SRC java
CountingSet set = new CountingSet();
set.addAll(Arrays.asList("1", "2", "3"));
// set.count == 6, хотя добавили 3 элемента!
#+END_SRC
Наследование реализации метода приводит к разным результатам в зависимости от реализации базового класса. Таким образом детали реализации прорываются через инкапсуляцию. 
Решение проблемы - использовать композицию классов (*favor composition over inheritance*).
**** Наследование и code reuse
#+ATTR_HTML: width = "100px"
#+ATTR_ORG: :width 100
[[./images/code_reuse_example.png]]
Хотим использовать класс XUsefulShape из проекта X в проекте Y. Варианты действий:
1) Перенести всю иерархию X в проект Y (при этом, возможно, часть функциональности будет дублироваться)
2) Создать класс YUsefulShape, как копию XUsefulShape с точностью до замены X на Y.
Таким образом, глубокие иерархии классов снижают code reuse. *Favor composition over inheritance*

Для того, чтобы ООП не создавало проблем, структура классов должна удовлетворять следующим свойствам:
1) Объекты должны быть по возможности неизменяемыми
2) Иерархии наследования не должны быть глубокими
3) Наследование реализации и переопределение методов использовать не нужно. 

*Algebraic data types*
ADT = OOP done right
ООП:
#+BEGIN_SRC java
abstract class Shape ...
class Circle extends Shape ...
class Rectangle extends Shape ...
class ComplexShape extends Shape ...
#+END_SRC
ADT:
#+BEGIN_SRC haskell
data Shape = Circle | Rectangle | ComplexShape
#+END_SRC
В ООП методы группируются по классам - в [[Algebraic Data Types][ADT]] подклассы группируются по методам (функциям).
[[./images/oop_adt.png]]
Из-за этого в ООП легко добавлять новые классы, не меняя код других классов; в ADT легко добавлять новые функции, не меняя код остальных функций. 
** Сравнение Haskell и других функциональных языков
*** Языки семейства ML
Standard ML, OCaml, F#
*Основные отличия от Haskell*:
- строгие вычисления вместо ленивых
- возможность написания не-чисто функциональных программ (наличие изменяемых данных и исключений)
  * возможность писать программы в императивном стиле
- отсутствие типов классов
- более продвинутая система модулей

Семейство ML-подобных языков создавалось в основном в 80-е - начале 90-х годов.
+ языки и реализации стабильные и зрелые, пригодны для промышленного использования.
- вышли из моды; интерес исследователей перешел к Haskell
- слабая поддержка многопоточности
- исследователи ФП в 80-е имели недостаточно опыта => стандартная библиотека SML/OCaml страдает непоследовательностью
- отсутствие классов типов приводит к необходимости иметь разные функции для разных типов. (в OCaml есть + для сложения целых чисел и +. для сложения вещественных)
*** Функциональная чистота 
Функция является *чистой*, если ее значение зависит только от значений входных параметров. 
Наличие в языке переменных противоречит чистоте. 
Важным для функциональных программ является свойство *referential transparency* (прозрачность по ссылкам). Вместо ссылки на функцию можно подставить ее определение:
#+BEGIN_SRC haskell
twice x = x + x
test = twice 10
-- эквивалентно:
test = 10 + 10
#+END_SRC
Referential transparency позволяет компилятору уменьшить количество промежуточных объектов при работе со списками и другими структурами данных. 
Плюсы функциональной чистоты:
+ бОльшие возможности для оптимизации
+ облегчение понимания и отладки программы; отлаживать функцию можно независимо от остальной программы
+ чистые функции проще объединять в композиции, так как между ними нет неявных связей в виде изменяемого состояния
+ чисто функциональные программы проще сделать параллельными; чистая функция всегда является thread-safe
Минусы:
- трудности при взаимодействии с внешним миром (I/O). В Haskell решается через монады:
  - монады в силу "вирусной" природы наинают загромождать всю программу
  - в случае повсеместного использования монады IO мы делаем программу императивной
- некоторые алгоритмы и структуры данных (массивы, хеш-таблицы) не имеют чисто-функциональных аналогов по эффективности.
*** Ленивость
- Строгие вычисления :: перед вызовом функции значения ее аргументов вычисляются (call-by-value)
#+BEGIN_SRC

f x y = y
f (1+2) (3+4)
-> f 3 7
-> 7
#+END_SRC
- Ленивые вычисления :: значения аргументов не вычисляются, аргументы передаются в виде невычисленных thunk'ов, которые форсируются по мере необходимости (call-by-need):
#+BEGIN_SRC
f x y = y
f (1+2) (3+4)
-> (3+4)
-> 7
#+END_SRC
Ленивый язык обязан быть чистым. 
+ можно присваивать значения в любом порядке, т.к. при ленивых вычислениях вычисление значения произойдет только при его использовании
+ можно использовать бесконечные СД; можно манипулировать ими так же, как и обычными - главное. чтобы никогда не вычислялся весь список целиком

Потребление памяти программой на Haskell может быть очень трудно предсказуемым. В Haskell есть дополнительные аннотации строгости.

Существует промежуточная стратегия вычислений - *lenient evaluation* (расслабленные вычисления), при которой аргументы вычисляются параллельно вычислению функции. 

Большинство мнений в ФП-сообществе считает, что повышения выразительности языка недостаточно велико по сравнению с проблемами поиска утечек памяти, так что лучше опциональная ленивость или lenient evaluation.

*** Идеальный функциональный язык
+ чистота по умолчанию с возможностью явно указывать возможные побочные эффекты функции
+ строгость по умолчанию с удобной опциональной ленивостью
* Ticket 2: Basic syntax
Инструкции (statement) в императивных языках в Haskell являются выражениями (expression).
** Функции   
*** Объявить функцию
#+BEGIN_SRC haskell
  fun :: argType (-> argType)* -> resType
#+END_SRC

*** Определить функцию
#+BEGIN_SRC haskell
  fun arg1 arg2 argN = smth
#+END_SRC

*** Вызов функции
#+BEGIN_SRC haskell
  fun arg1 arg2 argN
#+END_SRC

** Параметрический полиморфизм
#+BEGIN_SRC haskell
  fun :: argType (-> argType)* -> resType
  id  :: a -> a 
#+END_SRC
*Параметрический полиморфизм* - когда тип результата содержит одну или более
(не связанных) /переменных типа/, так что значение может принимать любой тип,
который получится от подстановки вместо этой переменной конкретного типа.

*Ad-hoc полиморфизм* - когда результат может иметь различные типы, потому что
для каждого типа дано свое определение (оператор + как пример).
** Базовый синтаксис (?)
*** Списки
~[type]~; конкатенация: ~++~ и ~l1:l2~; String ~ [Char]  
~head, tail, last, init, drop, take, replicate~
~zip/unzip/zipWith~
~l !! i~ - элемент по номеру, работает за линию

*** Лямбды 
#+BEGIN_SRC haskell
  \x -> x * x
#+END_SRC

*** let и where
~let~ bindings ~in~ expression
expresion ~where~ bindings

*** if
~if~ predicate ~then~ expression if true ~else~ expression if false

*** guards
#+BEGIN_SRC haskell
  fun x
      | predicate1
      | predicate2
      | …
      | otherwise (задефайнена как True)
#+END_SRC

*** case
#+BEGIN_SRC haskell
  fun x = case x of
      0 -> “a”
      1 -> “b”
      _ -> “e”
#+END_SRC

** Еще функции
*** Функции высшего порядка
#+BEGIN_SRC haskell
  apply :: Int -> Int -> (Int -> Int -> Int) -> Int
  apply a b f = f a b

  map    :: (a -> b) -> [a] -> [b]
  filter    :: (a -> Bool) -> [a] -> [a]
  foldr1  :: (a -> a -> a) -> [a] ->  a
#+END_SRC

Отличие foldr от foldr1 в том, что аккумулятором берется первый элемент
 списка (выпадет в рантайме на пустом списке!)
scanl/scanr - как foldl/foldr, только возвращают список всех промежуточных результатов

#+BEGIN_SRC haskell
  span   :: (a -> Bool)   -> [a] -> ([a], [a])

  uncurry :: (a -> b -> c) -> (a, b) -> c
  uncurry f (x, y) = f x y
#+END_SRC
*** Частичное применение функций:
(реальный тип `Int -> (Int -> Int)`)
#+BEGIN_SRC haskell
  sum :: Int -> Int -> Int  
  sum x y = x + y
#+END_SRC

*** flip
#+BEGIN_SRC haskell
  flip :: (a -> b -> c) -> b -> a -> c
  flip f b a = f a b
#+END_SRC

*** Pattern matching
#+BEGIN_SRC haskell
  fact :: Integer -> Integer
  fact 0 = 1
  fact n = n * fact (n - 1)
#+END_SRC

*** Композиция функций
#+BEGIN_SRC haskell
  infixr 9 .
  (.) :: (b -> c) -> (a -> b) -> a -> c -- композиция функций
  f . g = \x -> f (g x)

  infixr 0 $
  ($) :: (a -> b) -> a -> b  -- применение функции
  f $ x = f x
#+END_SRC
Понимать $ как “дальше следует последний аргумент к этой функции”
Применение можно само по себе рассматривать как функцию (в духе map ($ 3) [(+1), odd, even])

Point-free стиль: фокусирует внимание на функциях, а не на манипуляциях с данными
 (каррирование + композиция. Point здесь - “точка” не как знак композиции, а в смысле топологии)

** Всякое
*** Range
#+BEGIN_SRC haskell
  [0 .. 5]     -- [0, 1, 2, 3, 4, 5]
  [0, 2 .. 5]  -- [0, 2, 4]
  [0..]        -- [0, 1, 2, 3, ...] : бесконечный список
  [0, 2 ..]    -- [0, 2, 4, 6, ...] : все четные числа
  [5, 4 .. 1]  -- [5, 4, 3, 2, 1]
#+END_SRC

*** List comprehension
#+BEGIN_SRC haskell
  [x | x <- [1..10], even x]  -- [2, 4, 6, 8, 10]
  [x * y | x <- [1, 3, 5], y <- [2, 4, 6], x * y >= 10]  -- [12, 18, 10, 20, 30]
#+END_SRC

* Ticket 3: Datas, Classes, Instances
** Types, Type variables, Type aliases
*** Types
У всего в Haskell есть тип.
Базовые типы: Char, Bool, Int, Integer, Float, ...
*** Type variables
#+BEGIN_SRC haskell
head :: [a] -> a
fst :: (a, b) -> a
#+END_SRC
Функции, которые имеют переменные типов, называются *полиморфными функциями*.
*** Type aliases
#+BEGIN_SRC haskell
type BinaryIntFunction = Int -> Int -> Int
type String            = [Char]
type PairList a b      = [(a, b)]
#+END_SRC
В Java такого нет. В C++:
#+BEGIN_SRC c++
typedef std::fucntion<int(int int)> binary_int_fucntion;
#define int_vector std::vector<int>
using str = std::string;
#+END_SRC
** Algebraic Data Types
*** Тип-сумма
ST = T_1 + T_2 + ... + T_n
Java (special case): 
#+BEGIN_SRC java
public enum TrafficLight {
    RED, YELLOW, GREEN, BLUE
}
#+END_SRC 
C++ (also a special case):
#+BEGIN_SRC c++ 
union primitive_mess {
    long x;
    double y;
};
#+END_SRC
*** Тип-произведение
PT = T_1 \times T_2 \times ... \times T_n
C++:
#+BEGIN_SRC c++
// user = int \times string \times string
struct user {
    int uid;
    string login;
    striin pass;
};
#+END_SRC
*** ADT
T ::= Int | Char | Double | ...
ADT ::= T | ADT + ADT | ADT \times ADT
**** Enums 
#+BEGIN_SRC haskell 
data TrafficLight = Red | Yellow | Green | Blue
lightName :: TrafficLight -> String
lightName Red    = "red"
lightName Yellow = "yellow"
-- ...
#+END_SRC
Например, Bool является примером enumeration.
**** Structures
#+BEGIN_SRC haskell
data User = User Int String String
getUid :: User -> Int
getUid (User uid _ _) = uid
-- ...
#+END_SRC
**** Parametric
#+BEGIN_SRC haskell
data Vector a = Vector2D a a | Vector3D a a a
packVector :: Vector a -> [a]
packVector (Vector2D x y)   = [x, y]
packVector (Vector3D x y z) = [x, y, z]

vecLen :: Vector Double -> Double
vecLen = sqrt . sum . map (^2) . packVector
#+END_SRC
***** Maybe
#+BEGIN_SRC haskell
data Maybe a = Nothing | Just a
#+END_SRC 
***** Either
#+BEGIN_SRC haskell
data Either a b = Left a | Right b
-- Left - обычно ошибка, Right - получившееся значение
#+END_SRC 
**** Recursive
#+BEGIN_SRC haskell
data List a = Nil | Cons a (List a)
data [] a   = []  | a : [a]
#+END_SRC 
*** Record Syntax
#+BEGIN_SRC haskell
data User = User
    { uid      :: Int
    , login    :: String
    , password :: String
    }
-- не более чем синтаксический сахар для этого:
data User = User Int String String

uid :: User -> Int
uid (User i _ _) = i

login :: User -> String
login (User _ l _) = l

password :: User -> String
password (User _ _ p) = p
#+END_SRC
**** Record field patterns
#+BEGIN_SRC haskell
isIvan :: User -> BOOL
isIvan User { login = userName } = userName == "Ivan"
-- или
isIvan User { login = "Ivan" } = True
isIvan _                       = False
#+END_SRC
**** Record update syntax
#+BEGIN_SRC haskell 
cloneIvan :: User
cloneIvan = ivan { uid = 2 }
#+END_SRC
**** Duplicate Record Fields? 
#+BEGIN_SRC haskell
data User  = User  { uid :: Int, login :: String }
data Admin = Admin { aid :: Int, login :: String }
login :: ???
-- ограничение на названия полей
-- обходится в GHC 8 c DuplicateRecordFiled
data Person 
    = User  { uid   :: Int,    login :: String } 
    | Admin { login :: String, aid   :: Int    }
login :: Person -> String  -- real implementation
login (User  _ l) = l
login (Admin l _) = l
#+END_SRC
** Type Classes
*** Ad hoc polymorphis
Ad-hoc \equiv "for this", "for this specific purpose"
*Ad hoc polymorphism* is a kind of polymorphism in which polymorphic functions can be applied to arguments of different types, because a polymorphic function can denote a number of distinct and potentially heterogeneous implementations depending on the type of argument(s) to which it is applied. It is also known as function overloading or operator overloading. The term ad hoc in this context is not intended to be pejorative; it refers simply to the fact that this type of polymorphism is not a fundamental feature of the type system. (/from wikipedia/)
#+BEGIN_SRC haskell
class Printable p where
    printMe :: p -> String

data Foo = Foo

instance Printable Foo where
    printMe Foo = "Foo"
#+END_SRC
В Java - интерфейсы.
*** Multiple constraints
#+BEGIN_SRC haskell 
class I a where
    measure :: a -> Int -> Double

class J a where
    getParameter :: a -> Int

doMeasure :: (I a, J a) => a -> Double
doMeasure obj = measure obj $ getParameter obj
#+END_SRC
В Java:
#+BEGIN_SRC java 
public <T extends I & J> doubleDoMeasure(T obj) { ... }
#+END_SRC
*** Standard Type classes
**** Eq
Used for types that support _equality_ testing. The functions its members implement are (==) and (/=).
**** Ord
Used for type that have an _ordering_. Functions: (>), (<), (>=), (<=).
Ord \subset Eq.
#+BEGIN_SRC haskell
data Ordering = LT | EQ | GT
-- simplified version of Ord class
class Eq a => Ord a where
   compare              :: a -> a -> Ordering
   (<), (<=), (>=), (>) :: a -> a -> Bool

   compare x y
        | x == y    =  EQ
        | x <= y    =  LT
        | otherwise =  GT

   x <= y           =  compare x y /= GT
   x <  y           =  compare x y == LT
   x >= y           =  compare x y /= LT
   x >  y           =  compare x y == GT
#+END_SRC
**** Show
Members of this type class can be presented as _strings_.
**** Read
The ~read~ function _takes a string and returns a type_ which is a member of ~Read~.
**** Enum
Enum members are _sequentially ordered types_ - they can be enumerated. 
{(), Bool, Char, Ordering, Int, Integer, Float, Double} \subset Enum
**** Bounded
Bounded members have _an upper and a lower bound_.
{Int, Char, Bool, ()} \subset Bounded
**** Num
Its members have the property of being able to act like _numbers_.
{Int, Integer, Float, Double} \subset Num
**** Integral
Includes only integral (_whole_) numbers: Int and Integer
**** Floating
Includes only _floating point_ numbers: Float and Double.
*** deriving
#+BEGIN_SRC haskell
data TrafficLight = Red | Yellow | Green | Blue
    deriving (Eq, Ord, Enum, Bounded, Show, Read)
#+END_SRC 
*** DatatypeContexts
(It's better not to use it)
#+BEGIN_SRC haskell
data (Ord a) => OrderedList a = Nil | Node { value :: a, next :: OrderedList a }
-- we want
insert :: a -> OrderedList a -> OrderedList a
-- but we can't
#+END_SRC 
* Ticket 4: Kinda Monoids
** newtype
  - Сделано для изоморфизма, например, если хотим переопределить какие-либо инстансы.
  - ~newtype MyInt = MyInt Int~
  - НО: Может иметь только один конструктор и принимать одну переменную.
  - Теперь мы можем задерайвить нужные нам инстансы и переписать Ord (не дерайвя его есесна).
  - Кроме того, newtype жрет меньше памяти, чем аналогичная data, а еще позволяет явно “именовать” аргументы у функций
(вместо foo 10 20 будет foo (Size 10) (Time 20))

** Phantom types
  - Такие типы, в которых параметр слева не присутствует справа.
  (формально - параметризованные типы, не использующие тип-параметр в определении, во)
newtype Const a b = Const { getConst :: a }
  - Нужно это для имения типа:
    ~newtype Coin color = Coin { getCoin :: Int }~
  - У коина теперь есть тип - цвет и есть значение внутри.
  - из этого можно сделать чуть более наглядную вещь: 
#+BEGIN_SRC haskell
newtype Money currency = Money { amount :: Int }
data Dollars = Dollars { cash :: Money Dollars }
data Euro = Dollars {cash :: Money Euro }
#+END_SRC
типа запретили сравнивать разные валюты между собой

*** Record syntax
#+BEGIN_SRC haskell
  data Person = Person { firstName :: String  
                       , lastName :: String  
                       , age :: Int  
                       , height :: Float  
                       , phoneNumber :: String  
                       , flavor :: String  
                       } deriving (Show)   

--Record field patterns
isIvan :: User -> Bool
isIvan User { login = userName } = userName == "Ivan"

--Record update syntax
cloneIvan :: User
cloneIvan = ivan { uid = 2 }  -- User 2 "Ivan" "123"
#+END_SRC
* Ticket 5: Monads, part 1
** Объяснение на коробках 
[[./images/monad_box.png]]
** Определение
*Переменная* - контейнер для /данных/
*Монада* - контейнер для /вычисления/
Монады применяют функции, которые возвращают завернутые значения, к завернутому знаению.
#+BEGIN_SRC haskell
class Monad m where   -- m :: * -> *
    return :: a -> m a                  -- return
    (>>=)  :: m a -> (a -> m b) -> m b  -- bind
    (>>)   :: m a -> m b -> m b         -- then
    m >> k = m >>= \_ -> k
(=<<) :: Monad m => (a -> m b) -> m a -> m b
f =<< x = x >>= f
infixl 1  >>, >>=
infixr 1  =<<
#+END_SRC 
*Свойства монад*:
#+BEGIN_SRC haskell
return a >>= f  ≡ f a                      -- left identity
m >>= return    ≡ m                        -- right identity
(m >>= f) >>= g ≡ m >>= (\x -> f x >>= g)  -- associativity
#+END_SRC
** Базовые монады
*** Maybe
#+BEGIN_SRC haskell
data Maybe a = Nothing | Just a

instance Monad Maybe where
    return = Just
  
    Nothing >>= _ = Nothing
    Just a  >>= f = f a
#+END_SRC 
*** Identity
#+BEGIN_SRC haskell
newtype Identity a = Identity { runIdentity :: a }
instance Monad Identity where
    return  = Identity
    i >>= f = ...
#+END_SRC
*** Either
#+BEGIN_SRC haskell
data Either a b = Left a | Right b
instance Monad (Either e) where
    return = Right
    Right m >>= k = k m
    Left e  >>= _ = Left e
#+END_SRC
*** List
#+BEGIN_SRC haskell
instance Monad [] where
    return x = [x]
    l >>= f  = concat (map f l) -- or using concatMap
#+END_SRC
** Monad composition
#+BEGIN_SRC haskell
(.)   ::            (b ->   c) -> (a ->   b) -> a ->   c
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c

m >>= (f >=> g) ≡ m >>= f >>= g
m >>= (f <=< g) ≡ m >>= g >>= f

(f >=> g) >=> h ≡ f >=> (g >=> h)    -- associativity
#+END_SRC
** Joining monads
#+BEGIN_SRC haskell
join :: Monad m => m (m a) -> m a
#+END_SRC
К сожалению, нельзя сделать функцию ~extract~, которая работала бы для всех монад, так как комбинация основных функций монады не дает такой возможности. Чтобы вытаскивать значение, нужно знать больше информации о виде конкретной монады. Например, у ~Identity~ есть функция ~runIdentity~. 
#+BEGIN_SRC haskell 
extract :: Monad m => m a -> a
#+END_SRC
** Функции для монад
*Control.Monad*:
#+BEGIN_SRC haskell
liftM    :: Monad m => (a -> b) -> m a -> m b
liftM2   :: Monad m => (a -> b -> c) -> m a -> m b -> m c
#+END_SRC
*Control.Monad.Extra*:
#+BEGIN_SRC haskell
ifM   :: Monad m => m Bool -> m a -> m a -> m a
(||^) :: Monad m => m Bool -> m Bool -> m Bool
#+END_SRC
* Ticket 6. Functors & Applicative
** Functor
Применяет функцию к значению в контексте
#+BEGIN_SRC haskell
  class Functor f where         -- f :: * -> *
      fmap :: (a -> b) -> f a -> f b
      (<$) :: a -> f b -> f a
  instance Functor Maybe where
      fmap f (Just x) = Just (f x)
      fmap _ Nothing  = Nothing
  (<$>) :: Functor f => (a -> b) -> f a -> f b
  (<$>) = fmap
#+END_SRC
- ~fmap~ на ~[a]~ делает ~fmap~ к каждому элементу; если ~a~ - простой тип, то ~fmap = map~
- arrow functor: объединяем функции
#+BEGIN_SRC haskell
  instance Functor ((-> r)) where
    fmap = (.)

  >let foo = fmap (+3) (+2)
  >foo 10
  15
#+END_SRC
- Bifunctor: функтор для коробочек с 2 элементами

** Applicative
#+BEGIN_SRC haskell
  class Functor f => Applicative f where
      pure  :: a -> f a
      (<*>) :: f (a -> b) -> f a -> f b
      (*>) :: f a -> f b -> f b
      (<*) :: f a -> f b -> f a
  instance Applicative Maybe where
      pure = Just
      Nothing <*> _         = Nothing
      Just f  <*> something = fmap f something
  instance Applicative [] where
      pure x    = [x]
      fs <*> xs = [f x | f <- fs, x <- xs]
      -- декартово произведение функций и значений
#+END_SRC
- Функция в контексте, значение тоже в контексте, вытаскиваем и то,
  и другое из коробочек, применяем, суем обратно в коробочку
- arrow applicative
#+BEGIN_SRC haskell
  instance Applicative ((->) r) where
    pure x = \_ -> x
    f <*> g = \x -> f x (g x)
#+END_SRC
** Alternative
- Берет два аппликатива и возвращает левый, если он не empty, иначе правый
#+BEGIN_SRC haskell
  class Applicative f => Alternative f where
      empty :: f a
      (<|>) :: f a -> f a -> f a
  instance Alternative Maybe where
      empty = Nothing
      Nothing <|> r = r
      l       <|> _ = l
  ghci> Nothing <|> Just 3 <|> empty <|> Just 5
  Just 3
  instance Alternative [] where
      empty = []
      (<|>) = (++)
  ghci> [] <|> [1,2,3] <|> [4]
  [1,2,3,4]
#+END_SRC
- *guard*
#+BEGIN_SRC haskell
  guard           :: (Alternative f) => Bool -> f ()
  guard True      =  pure ()
  guard False     =  empty
#+END_SRC
** List comprehension syntax sugar
#+BEGIN_SRC haskell
  --Пишем так:
  sweetPythags = [(x,y,z) | z <- [1..], x <- [1..z], y <- [x..z], x^2 + y^2 == z^2]
  --На самом деле происходит так:
  pythagsWithoutSugar =
    [1..]  >>= \z ->
    [1..z] >>= \x ->
    [x..z] >>= \y ->
    guard (x^2 + y^2 == z^2) >>
    return (x, y, z)
#+END_SRC
** Traversable
- Как *Foldable*, ходит по структуре, собирая значения в каждой точке, 
  только сохраняет структуру
#+BEGIN_SRC haskell
  class (Functor t, Foldable t) => Traversable t where
    traverse  :: Applicative f => (a -> f b) -> t a -> f (t b)
    sequenceA :: Applicative f => t (f a) -> f (t a)
#+END_SRC
** Automatic deriving
- GHC может сгенерировать инстансы автоматически (~... deriving Functor~)
*** DeriveFunctor
*** DeriveFoldable
*** DeriveTraversable
** Type hierarchy proposals
*** AMP (Applicative/Monad proposal)
*** FTP (Foldable/Traversable proposal)
*** MRP (Monad of no return/>> proposal)
*** MFP (MonadFail proposal) 
* Ticket 7: Monads, part 2
** Writer monad
Хотим вести лог вычислений.
#+BEGIN_SRC haskell
binPow :: Int -> Int -> Int
binPow 0 _      = 1
binPow n a
    | even n    = let b = binPow (n `div` 2) a in b * b
    | otherwise = a * binPow (n - 1) a
type IntWithLog = (Int, String)

binPow :: Int -> Int -> IntWithLog
binPow 0 _      = (1, "")
binPow n a
    | even n    = let (b, msg) = binPow (n `div` 2) a 
                  in (b * b, msg ++ "Square " ++ show b ++ "\n")
    | otherwise = let (b, msg) = binPow (n - 1) a
                  in (a * b, msg ++ "Mul " ++ show a ++ " and " ++ show b ++ "\n")
#+END_SRC
*Writer monad*:
#+BEGIN_SRC haskell
newtype Writer w a = Writer { runWriter :: (a, w) } -- a is value, w is log
-- Writer w a type is just a newtype wrapper for a tuple (a, w); just a reminder of what newtype is

instance Monoid w => Monad (Writer w) where
    return a            = Writer (a, mempty)
    Writer (x, v) >>= f = let Writer (y, v') = f x
                          in Writer (y, v `mappend` v')

tell       :: w -> Writer w ()
execWriter :: Writer w a -> w
writer     :: (a, w) -> Writer w a
#+END_SRC
(from learnyouahaskell):
Now that our tuple is wrapped in the ~Writer~ ~newtype~, we have to unwrap it when pattern matching. We take the value ~x~ and apply the function ~f~ to it. This gives us a ~Writer w a~ value and we use a ~let~ expression to pattern match on it. We present ~y~ as the new result and use ~mappend~ to combine the old monoid value with the new one. We pack that up with the result value in a tuple and then wrap that with the ~Writer~ constructor so that our result is a ~Writer~ value instead of just an unwrapped tuple.

Sometimes we just want some monoid value to be included at some particular point. For this, the ~tell~ function is useful. It's part of the ~MonadWriter~ type class and in the case of ~Writer~ it takes a monoid value, like ~["This is going on"]~ and creates a ~Writer~ value that presents the dummy value ~()~ as its result but has our desired monoid value attached. When we have a monadic value that has ~()~ as its result, we don't bind it to a variable.

Воспользуемся ей для удобного лога:
#+BEGIN_SRC haskell 
binPow :: Int -> Int -> Writer String Int
binPow 0 _      = return 1
binPow n a
    | even n    = binPow (n `div` 2) a >>= \b ->    
                  tell ("Square " ++ show b ++ "\n") >>
                  return (b * b)
    | otherwise = binPow (n - 1) a >>= \b -> 
                  tell ("Mul " ++ show a ++ " and " ++ show b ++ "\n") >>
                  return (a * b)
-- или так
binPow n a
    | even n    = binPow (n `div` 2) a >>= \b -> 
                  writer (b * b, "Square " ++ show b ++ "\n")
    | otherwise = binPow (n - 1) a >>= \b -> 
                  writer (a * b, "Mul " ++ show a ++ " and " ++ show b ++ "\n")

-- запуск:
ghci> putStr $ execWriter $ binPow 3 2 >> binPow 3 7
#+END_SRC
** Reader monad
Что делать, если функция хочет иметь представление об окружающей среде? Нужно передать ей контекст в качестве аргумента
#+BEGIN_SRC haskell
data Environment = Environment
    { name    :: String
    , ids     :: [Int]
    , manager :: String -> String
    }

containsId :: Int -> Environment -> Bool
containsId i env = i `elem` ids env

safeCallManager :: Int -> Environment -> Maybe String
safeCallManager i env = if containsId i env
                        then Just $ manager env $ name env
                        else Nothing
#+END_SRC
*Reader monad*:
#+BEGIN_SRC haskell
newtype Reader e a = Reader { runReader :: e -> a }
ask   :: Reader e e
asks  :: (e -> a) -> Reader e a
local :: (e -> b) -> Reader b a -> Reader e a
instance Monad (Reader e) where
    return a = Reader $ \_ -> a
    m >>= f  = Reader $ \r -> runReader (f $ runReader m r) r
#+END_SRC
Применим ее для ~Environment~:
#+BEGIN_SRC haskell
containsId :: Int -> Reader Environment Bool
containsId i = asks (\env -> i `elem` ids env)

safeCallManager :: Int -> Reader Environment (Maybe String)
safeCallManager i = containsId i >>= \hasId -> 
                    if hasId
                    then asks (\env -> Just $ manager env $ name env)
                    else return Nothing
#+END_SRC
** Typed holes
#+BEGIN_SRC haskell
foo :: a -> b
foo x = _
-- Found hole '_' with type: b
bar :: [Int]
bar = map _f ["aba", "caba"]
-- Found hole '_f' with type: [Char] -> Int
#+END_SRC
** PartialTypeSignature
#+BEGIN_SRC haskell
{-# LANGUAGE PartialTypeSignatures #-}
foo :: _ -> Bool
foo x = not x

Main.hs:3:8: warning: [-Wpartial-type-signatures]
    • Found type wildcard ‘_’ standing for ‘Bool’
    • In the type signature:
        foo :: _ -> Bool
    • Relevant bindings include
        foo :: Bool -> Bool (bound at Main.hs:4:1)
#+END_SRC
** State monad
Необходимо хранить изменяющееся по мере вычисления состояние.
/Императивный/ стиль: изменить значение переменной
/Функциональный/ стиль: создать новую переменную с новым значением
Рассмотрим на примере стека:
#+BEGIN_SRC haskell
type Stack = [Int]

pop  :: Stack -> (Int, Stack)
push :: Int -> Stack -> Stack
pop  :: Stack -> (Int, Stack)
pop (x:xs) = (x, xs)

push :: Int -> Stack -> Stack
push x s = x:s
pop  :: Stack -> (Int, Stack)
pop (x:xs) = (x, xs)

push :: Int -> Stack -> ((), Stack)
push x s = ((), x:s)
stackOps :: Stack -> (Int, Stack)
stackOps s = let (x, xs)  = pop s
                 (_, s')  = push 5 xs
                 (_, res) = push 10 s'
             in (x, res)
#+END_SRC
*State monad*:
[[./images/state.png]]
#+BEGIN_SRC haskell
-- import Control.Monad.State
newtype State s a = State { runState :: s -> (a, s) }
instance Monad (State s) where
    return a       = State $ \s -> (a, s)
    oldState >>= f = State $ \s -> let (a, newState) = runState oldState s
                                   in runState (f a) newState
#+END_SRC
Стек с использованием ~State~:
#+BEGIN_SRC haskell
type Stack = [Int]

pop :: State Stack Int
pop = state $ \(x:xs) -> (x, xs)

push :: Int -> State Stack ()
push x = state $ \xs -> ((), x:xs)

stackOps :: State Stack Int
stackOps = pop >>= \x -> push 5 >> push 10 >> return x
#+END_SRC
Полезные функции для ~State~:
#+BEGIN_SRC haskell
get       :: State s s
put       :: s -> State s ()
modify    :: (s -> s) -> State s ()
gets      :: (s -> a) -> State s a
withState :: (s -> s) -> State s a -> State s a
evalState :: State s a -> s -> a
execState :: State s a -> s -> s
#+END_SRC
** RWS monad
#+BEGIN_SRC haskell
newtype RWS r w s a = RWST { runRWS :: r -> s -> (a, s, w) }
-- now
runRWS  :: RWS r w s a -> r -> s -> (a, s, w)
execRWS :: RWS r w s a -> r -> s -> (s, w)
evalRWS :: RWS r w s a -> r -> s -> (a, w)
#+END_SRC 
/Пример/:
#+BEGIN_SRC haskell
import Control.Monad.RWS

type R = Int
type W = [Int]
type S = Int

computation :: RWS R W S ()
computation = do
    e <- ask
    a <- get
    let b = a + e
    put b
    tell [b]

example = runRWS computation 2 3
#+END_SRC
** Continuation Passing Style
#+BEGIN_SRC haskell
add :: Int -> Int -> Int
add x y = x + y

addCPS :: Int -> Int -> (Int -> r) -> r
addCPS x y onDone = onDone (x + y)

onInput :: (String -> IO ()) -> IO ()  -- every callback framework
onInput action = forever $ getLine >>= action
#+END_SRC
*** Cont data type
#+BEGIN_SRC haskell

newtype Cont r a = Cont { runCont :: (a -> r) -> r }

cont :: ((a -> r) -> r) -> Cont r a
#+END_SRC
*** Cont Monad
#+BEGIN_SRC haskell
instance Monad (Cont r) where
    return a       = Cont ($ a)
    Cont arr >>= f = Cont $ \br -> arr $ \a -> runCont (f a) br
#+END_SRC
*** Достоинства CPS
+ Representation of program in compiler
+ Building coroutines
+ Introducing callbacks
+ Tail-recursive optimizations
+ Exception handling
*** MonadCont
#+BEGIN_SRC haskell
class Monad m => MonadCont m where
    callCC :: ((a -> m b) -> m a) -> m a  -- call-with-current-continuation
instance MonadCont (Cont r) where
    callCC :: ((a -> Cont r b) -> Cont r a) -> Cont r a
    callCC f = cont $ \c -> runCont (f (\x -> cont $ \_ -> c x)) c
#+END_SRC
* Ticket 8: RealWorld
** IO

*IO* идет вразрез с концепцией чистоты Haskell. Никто не гарантирует, что два вызова одного
и того же `getChar` дадут одинаковый результат. Компилятор считает все функции чистыми
(кажется, это грязная ложь) и может соптимизировать "лишние" вызовы и вернуть один
результат. 

#+BEGIN_SRC haskell
  getchar :: Char
  get2chars = [getchar, getchar]
#+END_SRC

Порядок, в котором вернутся результаты, не определен в `getChar`.

#+BEGIN_SRC haskell
  getchar   :: Int -> Char
  get2chars :: Int -> String
 
  get2chars _ = [getchar 1, getchar 2]
  -- У нас получились разные `getchar`, и мы точно сделаем их два раза.
#+END_SRC

#+BEGIN_SRC haskell
  getchar :: Int -> (Char, Int)

  get2chars _ = [a,b] where (a,i)  = getchar 1
                            (b,_)  = getchar i
  get2chars i = [a,b] where (a,i1) = getchar i
                            (b,i2) = getchar i1
  -- Теперь мы определились с порядком вызова
  -- А что делать с get4chars = [get2chars 1, get2chars 2]?

  get4chars = [get2chars 1, get2chars 2]

  get4chars :: Int -> String
  get4chars i0 = (a++b) where (a,i1) = get2chars i0
                              (b,i2) = get2chars i1
  -- Так оно и работает на самом деле
#+END_SRC

Какой в действительности тип у `main`?
#+BEGIN_SRC haskell
  type IO a  =  RealWorld -> (a, RealWorld)

  main :: RealWorld -> ((), RealWorld)
  main :: IO ()

  getChar :: RealWorld -> (Char, RealWorld)
 
  main :: RealWorld -> ((), RealWorld)
  main world0 = 
      let (a, world1) = getChar world0
          (b, world2) = getChar world1
      in ((), world2)

  --    Can we skip getChar call?
  --    Can we swap getChar calls?
  --    Duplicate getChar calls?

#+END_SRC

Страшная правда об *IO*: 

#+BEGIN_SRC haskell
  newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))

  -- | @State\#@ is the primitive, unlifted type of states.  It has
  --         one type parameter, thus @State\# RealWorld@, or @State\# s@,
  --         where s is a type variable. The only purpose of the type parameter
  --         is to keep different state threads separate.  It is represented by
  --         nothing at all. 

  data State# s

  -- | @RealWorld@ is deeply magical.  It is /primitive/, but it is not
  --         /unlifted/ (hence @ptrArg@).  We never manipulate values of type
  --         @RealWorld@; it\'s only used in the type system, 
  --         to parameterise @State\#@.

  data RealWorld
#+END_SRC

То есть *RealWorld* сам по себе лучше не трогать, он служит, чтобы параметризовать
*State#*.

** `do` notation: desugaring `>>`

* Ticket 9: Monad Transformers
* Ticket 10: Speeding up Haskell
* Ticket 11: Template Haskell and Lens
* Ticket 12: Parallel and Concurrent Haskell
* Ticket 13: Comonads
* Ticket 14: Enterprise Haskell
* Ticket 15: Advanced type features
* Ticket 16: Idris

