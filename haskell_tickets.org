* Ticket 1. Why FP and Haskell? 
** Основные идеи ФП:
- Сборка мусора
- Замыкания
- Вывод типов [[type inference]]
- Ленивая обработка (lazy evaluation) 
- Функции высшего поряда
** Статическая типизация
*** Деление языков
- Языки с статической типизацией
  * ФП :: Haskell, SML, OCaml, F#
  * ООП-императивные :: Java, C#, C++
- Языки с динамической типизацией
  * Python, Ruby, JavaScript, Erlang, Lisp

*** Преимущества статической типизации
+ Раннее обнаружение ошибок :: Ошибки находятся на этапе компиляции, а не выполнения. Часто программа на SML или Haskell работает правильно, как только ее наконец удается скомпилировать
+ Высокая поддерживаемость больших проектов :: Изменения могут быть верифицированы компилятором, и типы являются частью документации программы, облегчая ее понимание
+ Автоматизированная обработка программ :: Например, автоматический рефакторинг, как в средах IDEA или Eclipse
+ Оптимизация кода :: Код, написанный на статически типизированном языке, проще оптимизировать, так что в среднем статически типизированный язык эффективнее динамически типизированных
*** <<Type inference>>
Статические языки слишком многословны
#+BEGIN_SRC java
List<T> replicate(int n, T elem) {
    List<T> list = new ArrayList<T>(n);
    for (int i = 0; i < n; i++) {
        list.add(elem);
    }
    return list;
}
#+END_SRC
Но вывод типов позволяет не писать явные объявления типов - компи
Если же постоянно обнаруживается учащенный пульс – более 90 ударов в минуту – это может быть следствием вашего лятор выводит их самостоятельно из контекста. 
#+BEGIN_SRC haskell
replicate 0 _ = []
replicate n elem = elem : replicate (n - 1) elem
#+END_SRC

** Конструкции Haskell
+ Ортогональность :: Язык состоит из небольшого числа независимых базовых конструкций, которые можно произвольно комбинировать между собой, получая сколь угодно сложные конструкции. В C нельзя возвращать массив из функций. В С++ многие возможности дублируются (функции/методы, указатели/ссылки). 
+ Замыкания (closures) :: Трудно реализовать в языках без сборки мусора типа C++.
+ Каррирование (currying) :: То же, что и для замыканий, плюс проблемы с перегрузкой функций по числу аргументов, как принято во многих императивных языках.
+ Вывод типов ([[type inference]]) :: Глобальный вывод типов накладывает серьезные ограничения на систему типов; Так, наличие наследования резко ослабляет возможности вывода типов.
+ Сопоставление с образцом (pattern matching) :: 
+ Классы типов (type classes) ::
** Сравнение императивных и функциональных языков
*** Изменяемое состояние (mutable state)
**** Проблема нелокальности (aliasing)
На один и тот же объект могут быть несколько ссылок. Если объект изменяемый, то изменение по одной ссылке приводит к изменениям по другим ссылкам. 
- Неправильная работа программы
- Долгая и сложная отладка ошибки
Для решения проблемы используется копирование объектов (*defensive copy*), но:
- Нужно знать, когда нужно копировать, а когда нет
- Копирование больших объектов может быть неэффективным

Проблема исчезает, если использовать *неизменяемые объекты* (*immutable objects*) :: все "изменяющие" методы возращают *новый* объект.
+ Не нужно копирование объектов
+ Современные сборщики мусора лучше заточены под большое количество объектов с малым сроком жизни, поэтому можно не бояться создавать новые объекты при вызове методов.
+ Aliasing для изменяемых данных создает проблемы при оптимизации кода, так как запись в память может приводить к изменению закэшированных в регистрах значений. Для неизменяемых данных aliasing не создает проблем.
**** Комбинаторная сложность и поддержаение инвариантов
Для значений полей объекта чаще всего должны выполняться условия корректности - *инварианты*. Каждый метод, изменяющий состояние объекта, должен проверять сохранения инварианта. 
В изменяемом объекте любой метод может изменить любое поле. Сложность работы по корректной поддержке инвариантов:
*[Количество полей] * [Количество методов]*

Для неизменяемых обхектов - *инварианты достаточно проверять только при создании объекта*.

**** Зависимость от истории 
Корректность состояния изменяемых объектов зависит от порядка вызова методов.
Если объект передается между разными модулями, которые ожидают определенной последовательности вызовов метода объекта. Это создает неявные связи между модулями, которые очень трудно тестировать и поддерживать.
*Для неизменяемых объектов опять же этой проблемы нет, так как объект никак не меняется при вызове его методов.*
**** Хранение объектов в коллекциях
#+BEGIN_SRC java
Point p = new Point(1, 2);
Set<Point> set = new HashSet<Point>();
set.add(p);
p.move(-1, 0);
boolean isInSet = set.contains(p); // может быть false
#+END_SRC
**** Многопоточный доступ
При доступе к изменяемым полям объекта одновременно из нескольких потоков требуется синхронизация, что является довольно неэффективной операцией. 
Для неизменяемых данных синхронизация не нужна, так как потоки только читают данные. 
Параллельные выисления в функциональных языках проще, так как:
+ Отсутствует необходимость расстановки блоков синхронизации, что упрощает программирование
+ Чистые функции всегда можно выполнять параллельно, так то не нужно задумываться над возможными побочными эффектами.
+ В Haskell с помощью монад можно проверять корректность параллелизации кода на этапе компиляции.
*** ООП
**** Наследование и изменяемость
#+BEGIN_SRC java
class Rectangle {
    private int w;
    private int h;
    Rectangle(int w, int h) {
        this.w = w; this.h = h;
    }
    void setWidth(int newW) { ... }
    void setHeight(int newH) { ... }
}
class Square extends Rectangle {
    Square(int side) {
        super(side, side);
    }
}
#+END_SRC
#+BEGIN_SRC java
void test(Rectangele rect) {
    rect.setWidth(5);
    rect.setHeight(4);
    assert(rect.getWidth() == 5 && rect.getHeight() == 4);
}
Square sq = new Square(3);
test(sq); // ???
#+END_SRC
Это нарушение *Liskov Substitution Principle*: Функция. которая принимает значения типа Т, должна также обрабатывать и значения любого подтипа Т.
Обратное наследование также является ошибочным:
#+BEGIN_SRC java
class Rectangle extends Square ...
void test(Square square) {
   int area = square.getSize() * square.getSize();
   assert(area == square.getArea());
}
Rectangle rect = new Rectangle(5, 3);
test(rect);
#+END_SRC
Единственное корректное решение - убрать методы set из Rectangle и Square, сделав их неизменяемыми.
**** Inheritance breaks encapsulation
Хотим посчитать, сколько раз в коллекцию добавлялся элемент.
#+BEGIN_SRC java
class CountingSet extends HashSet {
   private int count = 0;
   public boolean add(Object o) {
       count++;
       return super.add(o);
   }
   public boolean addAll(Collection c) {
       count += c.size();
       return super.addAll(c);
   }
}
#+END_SRC
*НО*:
#+BEGIN_SRC java
CountingSet set = new CountingSet();
set.addAll(Arrays.asList("1", "2", "3"));
// set.count == 6, хотя добавили 3 элемента!
#+END_SRC
Наследование реализации метода приводит к разным результатам в зависимости от реализации базового класса. Таким образом детали реализации прорываются через инкапсуляцию. 
Решение проблемы - использовать композицию классов (*favor composition over inheritance*).
**** Наследование и code reuse
#+ATTR_HTML: width = "100px"
#+ATTR_ORG: :width 100
[[./code_reuse_example.png]]
Хотим использовать класс XUsefulShape из проекта X в проекте Y. Варианты действий:
1) Перенести всю иерархию X в проект Y (при этом, возможно, часть функциональности будет дублироваться)
2) Создать класс YUsefulShape, как копию XUsefulShape с точностью до замены X на Y.
Таким образом, глубокие иерархии классов снижают code reuse. *Favor composition over inheritance*

Для того, чтобы ООП не создавало проблем, структура классов должна удовлетворять следующим свойствам:
1) Объекты должны быть по возможности неизменяемыми
2) Иерархии наследования не должны быть глубокими
3) Наследование реализации и переопределение методов использовать не нужно. 

*Algebraic data types*
ADT = OOP done right
ООП:
#+BEGIN_SRC java
abstract class Shape ...
class Circle extends Shape ...
class Rectangle extends Shape ...
class ComplexShape extends Shape ...
#+END_SRC
ADT:
#+BEGIN_SRC haskell
data Shape = Circle | Rectangle | ComplexShape
#+END_SRC
В ООП методы группируются по классам - в ADT подклассы группируются по методам (функциям).
[[./oop_adt.png]]
Из-за этого в ООП легко добавлять новые классы, не меняя код других классов; в ADT легко добавлять новые функции, не меняя код остальных функций. 
** Сравнение Haskell и других функциональных языков
*** Языки семейства ML
Standard ML, OCaml, F#
*Основные отличия от Haskell*:
- строгие вычисления вместо ленивых
- возможность написания не-чисто функциональных программ (наличие изменяемых данных и исключений)
  * возможность писать программы в императивном стиле
- отсутствие типов классов
- более продвинутая система модулей

Семейство ML-подобных языков создавалось в основном в 80-е - начале 90-х годов.
+ языки и реализации стабильные и зрелые, пригодны для промышленного использования.
- вышли из моды; интерес исследователей перешел к Haskell
- слабая поддержка многопоточности
- исследователи ФП в 80-е имели недостаточно опыта => стандартная библиотека SML/OCaml страдает непоследовательностью
- отсутствие классов типов приводит к необходимости иметь разные функции для разных типов. (в OCaml есть + для сложения целых чисел и +. для сложения вещественных)
*** Функциональная чистота 
Функция является *чистой*, если ее значение зависит только от значений входных параметров. 
Наличие в языке переменных противоречит чистоте. 
Важным для функциональных программ является свойство *referential transparency* (прозрачность по ссылкам). Вместо ссылки на функцию можно подставить ее определение:
#+BEGIN_SRC haskell
twice x = x + x
test = twice 10
-- эквивалентно:
test = 10 + 10
#+END_SRC
Referential transparency позволяет компилятору уменьшить количество промежуточных объектов при работе со списками и другими структурами данных. 
Плюсы функциональной чистоты:
+ бОльшие возможности для оптимизации
+ облегчение понимания и отладки программы; отлаживать функцию можно независимо от остальной программы
+ чистые функции проще объединять в композиции, так как между ними нет неявных связей в виде изменяемого состояния
+ чисто функциональные программы проще сделать параллельными; чистая функция всегда является thread-safe
Минусы:
- трудности при взаимодействии с внешним миром (I/O). В Haskell решается через монады:
  - монады в силу "вирусной" природы наинают загромождать всю программу
  - в случае повсеместного использования монады IO мы делаем программу императивной
- некоторые алгоритмы и структуры данных (массивы, хеш-таблицы) не имеют чисто-функциональных аналогов по эффективности.
*** Ленивость
- Строгие вычисления :: перед вызовом функции значения ее аргументов вычисляются (call-by-value)
#+BEGIN_SRC

f x y = y
f (1+2) (3+4)
-> f 3 7
-> 7
#+END_SRC
- Ленивые вычисления :: значения аргументов не вычисляются, аргументы передаются в виде невычисленных thunk'ов, которые форсируются по мере необходимости (call-by-need):
#+BEGIN_SRC
f x y = y
f (1+2) (3+4)
-> (3+4)
-> 7
#+END_SRC
Ленивый язык обязан быть чистым. 
+ можно присваивать значения в любом порядке, т.к. при ленивых вычислениях вычисление значения произойдет только при его использовании
+ можно использовать бесконечные СД; можно манипулировать ими так же, как и обычными - главное. чтобы никогда не вычислялся весь список целиком

Потребление памяти программой на Haskell может быть очень трудно предсказуемым. В Haskell есть дополнительные аннотации строгости.

Существует промежуточная стратегия вычислений - *lenient evaluation* (расслабленные вычисления), при которой аргументы вычисляются параллельно вычислению функции. 

Большинство мнений в ФП-сообществе считает, что повышения выразительности языка недостаточно велико по сравнению с проблемами поиска утечек памяти, так что лучше опциональная ленивость или lenient evaluation.

*** Идеальный функциональный язык
+ чистота по умолчанию с возможностью явно указывать возможные побочные эффекты функции
+ строгость по умолчанию с удобной опциональной ленивостью
