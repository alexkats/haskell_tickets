* Вопросы по темам 
** Question 1: Intro
*** Перечислите основные парадигмы ФП и Haskell, отличительные особенности
1. FP: 
   1. Иммутабельность
   2. Чистота
   3. Статическая типизация и вывод типов
   4. Функции высшего порядка
2. Haskell:
   1. Ленивые вычисления
   2. Pattern matching
   3. Type classes
*** Укажите преимущества чистоты
1. Есть referential transparency \Rightarrow есть бОльшие возможности для оптимизации
2. Проще делить программу на независимые модули и отлаживать их по отдельности (\approx один модуль - одна функция) 
3. Чистые фукнции проще объединять в композиции, так как между ними нет неявных связей в виде изменяемого состояния
4. Чисто функциональные программы проще сделать параллельными
*** Укажите преимущества ленивых вычислений
1. Можно присваивать значения в любом порядке, так как при ленивых вычислениях вычисление значения произойдет только при его использовании
2. Можно использовать бесконечные структуры данных
3. Ленивый язык более выразительный, чем строгий
4. Иногда можно улучшить эффективность использования памяти при ленивых вычислениях.
*** Укажите преимущества иммутабельности
1. Нет проблемы нелокальности: изменение по одной ссылке не приведет к изменениям по остальным ссылкам, так как "изменяющая" функция вернет новый объект
2. Нет необходимости в копировании объектов
3. Инварианты достаточно проверять только при создании объекта
4. Нет зависимости от истории \Rightarrow нет зависимости от порядка вызова методов
5. Безопасное хранение объекта в коллекции
6. Не требуется синхронизация, так как все потоки только читают данные

*** Укажите преимущества статической типизации

** Question 2: Basic Syntax
*** Имеется класс типов: ~class C a where maxInt :: Int~. Реализуйте данный класс типов для какого-нибудь типа данных.
*** Имеется класс типов: ~class C a where intGetter :: a -> Int~. Реализуйте данный класс типов для какого-нибудь типа данных.
*** Как обновить ~f~ в ~data A = A { f :: Int -> Int }; c = A { b = (+1) }~?
*** Что дает слово "*deriving*"? Что это в языке Haskell? 
*** Напишите реализацию ~foldr~ и ~foldl~. И нарисуйте картинку вычисления
*** Синтаксическим сахаром для какого кода является объявление следующего типа данных: ~data MyData = A { f :: Int, g :: Int -> Double }~
*** Напишите тип выражения ~flip id~.
*** Напишите тип выражения ~((+) . )~
*** Напишите тип выражения ~(.) . (.)~
*** Имеется тип данных ~data A a = B { f :: Double }~. Укажите тип ~f~.    
*** В чем отлиие ~data~ от ~newtype~?
*** Что такое "*Currying* (каррирование)" и *функции высшего порядка*?
*** Напишите, что такое DatatypeContexts? Приведите пример (не из презентации)
Ограничения на параметры в объявлениях ~data~ и ~newtype~. Объявленные таким образом типы требуют выполнения ограничений при создании (/construction/) и деконструкции (/deconstruction/, \approx разбиение конструктора при паттерн-матчинге), даже если эти ограничения неиспользуются. (deprecated in Haskell 7.2)
#+BEGIN_SRC haskell
data Eq a => Foo a = Constr a

-- не можем написать функцию:
isEq :: Foo a -> Foo a -> Bool
-- должны написать:
isEq :: Eq a => Foo a -> Foo a -> Bool
isRa (Constr x) (Constr y) = x == y

-- не сработает:
getVal :: Foo a -> a
-- сработает:
getVal :: Eq a => Foo a -> a
getVal (Constr x) = x
#+END_SRC
*** Напишите тип следующей функции в наиболее общем виде: ~f a = map (* a) . map (uncurry (+)) . map (\x -> (x, x))~
#+BEGIN_SRC haskell 
f :: Num a => a -> [a] -> [a]
#+END_SRC
*** Напишите функцию с типом, которая принимает список пар чисел и оставляет только такие, что сумма чисел в паре четная. 
#+BEGIN_SRC haskell
evenPairs :: (Integral a) :: [(a, a)] -> [(a, a)]
evenPairs = filter (even . uncurry (+))
#+END_SRC 
*** Задан тип данных ~data Role a = A { name :: String, role :: a } | B { name :: String, roles :: [a] }~. Напишите конструкцию, синтаксическим сахаром для которой является данных Record Syntax.
#+BEGIN_SRC haskell
data Role a = A String a | B String [a]
#+END_SRC

** Question 3: Kinds
*** Приведите пример типа с kind'ом ~Constraint -> *~
*** Приведите пример типа с kind'ом ~(* -> Constraint) -> Constraint~
*** Приведите пример типа с kind'ом ~(* -> *) -> Constraint~
*** Приведите пример типа с kind'ом ~(* -> Constraint) -> *~
*** Укажите kind для ~Monad~
*** Укажите kind следующего типа данных: ~data A f g = B (f g) (g f)~
*** Укажите kind следующего типа данных: ~data A f g = B (f g Int)~
*** Укажите kind типа ~type C p = p Int => Int~
*** Укажите kind типа ~type C p = (p Int, p Double)~
** Question 4: Type hierarchy
*** Чему равно значение ~length (Left "hello")~ и почему?
*** Чему равно значение ~length (Just [1..10])~ и почему?
*** Напишите type class ~Traversable~
*** Напишите реализацию ~Traversable~ для списка
*** Напишите реализацию ~Traversable~ для ~Maybe~ 
*** Напишите реализацию ~Traversable~ для ~Either~
*** Напишите реализацию ~Foldable~ для списка 
*** Напишите реализацию ~Foldable~ для ~Maybe~
*** Напишите реализацию ~Foldable~ для ~Either~
*** Напишите, что делают эти расширения языка: ~TypeSynonyms, MultiParamTypeClasses, ViewPatterns, RecordsWildCards~
*** Реализуйте ~traverse~ через ~sequence~.
*** Реализуйте ~sequence~ через ~traverse~.
*** Укажите *minimal complete definition* для type class'а ~Foldable~
*** Укажите *minimal complete definition* для type class'а ~Traversable~
** Question 5: Functors
*** Напишите законы *функтора*
*** Реализуйте функцию ~(<<$>>) :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)~ 
*** Напишите класс типов ~Bifunctor~ и реализуйте его для пары
*** Напишите класс типов ~Bifunctor~ и реализуйте его для ~Either~
*** Реализуйте ~fmap~ через ~bind~
** Question 6: Applicatives
*** Напишите type class ~Applicative~ и его реализацию для ~((->) r)~
*** Напишите type class ~Applicative~ и его реализацию для ~ZipList~
*** Реализуйте функцию ~liftA3~
*** Реализуйте функцию ~liftAA2 :: (Applicative f, Applicative g) => (a -> b -> c) -> f (g a) -> f (g b) -> f (g c)~
*** Реализуйте функцию ~(<<*>>) :: (Applicative f, Applicative g) => f (g (a -> b)) -> f (g a) -> f (g b)~
*** Реализуйте функцию ~eitherA :: (Alternative f) => f a -> f b -> f (Either a b)~
*** Есть функция ~g :: a -> b~ и объект ~x :: Applicative f => f a~. Напишите два разных способа получить объект ~y :: Applicative f => f b~ из ~x~ с использованием ~g~.
** Question 7: Monads
*** Что такое монада?
Монады применяют функции, которые возвращают завернутые значения, к завернутому знаению.
#+BEGIN_SRC haskell
class Monad m where   -- m :: * -> *
    return :: a -> m a                  -- return
    (>>=)  :: m a -> (a -> m b) -> m b  -- bind
    (>>)   :: m a -> m b -> m b         -- then
    m >> k = m >>= \_ -> k
(=<<) :: Monad m => (a -> m b) -> m a -> m b
f =<< x = x >>= f
infixl 1  >>, >>=
infixr 1  =<<
#+END_SRC 
*** Напишите не меньше пяти типов данных, являющихся монадой
1. []
2. Maybe
3. Either
4. IO
5. State
6. Identity
7. Writer
8. Reader
9. RWS
10. Cont
*** Напишите не менее семи функций, полезных при работе с монадами
1. return
2. >>=
3. =<<
4. >>
5. liftM
6. liftM2
7. >=>
8. <=<
9. join
10. ifM
11. (||^)
*** Отличие ~unsafePerformIO~ от ~unsafeInterleaveIO~?
*** Напишите тип функции ~join~ и приведите несколько примеров использования
*** Реализуйте ~join~ через ~bind~.
*** Напишите реализацию ~Monad~ для списка
*** Напишите реализацию ~Monad~ для ~Maybe~
#+BEGIN_SRC haskell
data Maybe a = Nothing | Just a

instance Monad Maybe where
    return = Just
    Nothing >>= _ = Nothing
    Just a  >>= f = f a
#+END_SRC 
*** Напишите реализацию ~Monad~ для ~Either~
*** Напишите определение типа данных ~Writer~ и его ~instance Monad~
*** Напишите определение типа данных ~Reader~ и его ~instance Monad~
*** Напишите определение типа данных ~State~ и его ~instance Monad~
*** Напишите определение типа данных ~Cont~ и его ~instance Monad~
*** Что такое ~IO~? Как теоретически это реализовано? 
*** Покажите, синтаксическим сахаром для чего является ~do~-нотация (включая ~let~).
*** Напишите тип ~(>=>)~ и смысл этого оператора.
** Question 8: Trans
*** Напишите класс типов ~MonadTrans~ и реализуйте его для ~StateT~
*** Напишите класс типов ~MonadTrans~ и реализуйте его для ~WriterT~
*** Напишите класс типов ~MonadTrans~ и реализуйте его для ~MaybeT~
*** Напишите класс типов ~MonadTrans~ и реализуйте его для ~ReaderT~
*** Напишите тип ~StateT~ и то, как определен ~State~ через ~StateT~
*** Напишите тип ~MaybeT~ и реализуйте его инстанс ~Monad~
*** Нарисуйте табличку отличий обычных типов и их трансформеров для известных вам трансформеров
** Question 9: Strict Lazy
*** Что такое *irrefutable patterns* и зачем они нужны?
*** Что такое *Stream Fusion* и зачем он нужен?
*** Напишите, что значит тип ~ST~ и напишите основные функции по работе с ним
*** Что такое ~BangPatterns~? Когда их нужно использовать? 
*** Укажите, что делает ~deepseq~ и как.
*** В чем разница между ~seq~ и ~deepseq~?
*** В чем разница между ~seq~ и ~BangPatterns~?
*** Что такое ~STRef~ и в чем отличие от ~IORef~?
*** Что такое *Deforestation*?
*** Чем плохо использовать ~IORef~ и ~IOArray~? Зачем нужны ~STRef~ и ~STArray~?
** Question 10: TemplateHaskell
*** Как можно посмотреть *AST-дерево* для выражения в Haskell?
*** Напишите не меньше трех применений *TemplateHaskell*
*** Что такое ~Q~ в типах функций Template Haskell?
*** В чем разница между ~[| |]~ и ~$()~?
** Question 11: Lenses
*** Что такое изоморфизм (~Iso~)?
*** Чем линзы отличаются от призм?
*** Напишите тип ~Iso~
*** Напишите тип функции ~from~ для ~Iso~
*** Напишите тип функции ~iso~
*** Напишите реализацию ~over~
*** Реализуйте ~set~ через ~over~
*** Реализуйте ~over~ через ~view~ и ~set~. 
*** Напишите функцию ~lens~, которая принимает геттер и сеттер и возвращает линзу
*** Укажите операторные обозначений функций ~view~, ~set~, ~over~. Есть ли отличие в типах функций и их операторных выражений?
** Question 12: Threads
*** Что такое ~STM~ (коротко), что позволяет делать и какие есть функции по работе с ним?
*** В чем отличие Haskell потоков от, например, потоков в Java?
*** Что такое ~Strategy~? Перечислите несколько стратегий и реализуйте некоторые. Зачем они нужны?
*** Как в Haskell обстоят дела с *DeadLock*'ами?
*** Что такое *RTS*?
*** Укажите несколько полезных опций *RTS*
*** Опишите, что такое ~MVar~, зачем он может быть нужен и несколько функций по работе с этим объектом.
*** Что делает ~forkIO~? Чем он отличается от ~forkFinally~?
** Question 13: forall
*** Напишите, как иметь список объектов разных функторов, внутри каждого из которых значения одинакового типа, чтобы иметь возможность применить функции из этого значения в другое?
*** Зачем нужно расширение ~ExistentialQuantification~?
*** Зачем нужно расширение языка ~-XExplicitForall~?
*** В чем разница между ~-XRank2Types~ и ~-XRankNTypes~? Зачем нужны оба?
*** Зачем нужно расширение языка ~-XScopedTypeVariables~ и как оно взаимодействует с ~forall~?
** Question 14: Advanced types
*** Что такое *typed holes* и зачем они нужны?
*** Зачем нужно расширение языка ~-XTypeApplications~?
*** Зачем нужно расширение языка ~-XPartialSignatures~?
*** Можно ли создать следующий тип данных в Haskell: ~data a : > b = (a -> b) : > (b -> a)~?
*** Что такое *Functional Dependencies*? Назовите какой-нибудь известный вам type class, в котором присутствуют функциональные зависимости.
** Question 15: Comonads
*** Напишите пример использования *комонад* 
*** Напишите, какие комонады двойственны монадам ~Reader, Writer, State~
*** Напишите, какие комонады двойственны монадам ~Traced, Store, Env~
*** Напишите комонаду ~Stream~ и инстанс ~Comonad~ для нее.
*** Напишите комонаду ~Env~ и инстанс ~Comonad~ для нее.
*** Напишите комонаду ~Store~ и инстанс ~Comonad~ для нее.
*** Напишите комонаду ~Traced~ и инстанс ~Comonad~ для нее.
*** Реализуйте ~instance Comonad~ для обычного ~Zipper~
*** ~IO~ использует абстракцию монад, какой аналог есть в мире комонад?
*** Напишите класс ~ComonadTrans~
*** Как можно было бы сделать ~codo~ нотацию для комонад? И что бы происходило в этом синтаксическом сахаре?
** Question 16: Idris
*** Реализуйте функцию ~take~ для вектора на Idris
*** Реализуйте функцию ~filter~ для вектора на Idris
*** Реализуйте функцию ~head~ для списка на Idris, которая компилируется только с гарантированно непустыми списками.
*** Напишите тип "*зависимая пара*" на Idris
*** Что такое ~[| |]~-идиома в Idris?
*** Что такое ~!~-идиома в Idris?
*** Что такое ~_|_-eliminator~? Зачем это надо?
*** Что такое "*тотальность*" и какие преимущества она дает? 
