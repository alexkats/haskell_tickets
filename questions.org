* Вопросы по темам
** [5/5]Question 1: Intro
*** DONE Перечислите основные парадигмы ФП и Haskell, отличительные особенности
1. FP:
   1. Иммутабельность
   2. Чистота
   3. Статическая типизация и вывод типов
   4. Функции высшего порядка
2. Haskell:
   1. Ленивые вычисления
   2. Pattern matching
   3. Type classes
*** DONE Укажите преимущества чистоты
1. Есть referential transparency \Rightarrow есть бОльшие возможности для оптимизации
2. Проще делить программу на независимые модули и отлаживать их по отдельности (\approx один модуль - одна функция)
3. Чистые фукнции проще объединять в композиции, так как между ними нет неявных связей в виде изменяемого состояния
4. Чисто функциональные программы проще сделать паралgit@github.com:baba-beda/haskell_tickets.gitлельными
*** DONE Укажите преимущества ленивых вычислений
1. Можно присваивать значения в любом порядке, так как при ленивых вычислениях вычисление значения произойдет только при его использовании
2. Можно использовать бесконечные структуры данных
3. Ленивый язык более выразительный, чем строгий
4. Иногда можно улучшить эффективность использования памяти при ленивых вычислениях.
*** DONE Укажите преимущества иммутабельности
1. Нет проблемы нелокальности: изменение по одной ссылке не приведет к изменениям по остальным ссылкам, так как "изменяющая" функция вернет новый объект
2. Нет необходимости в копировании объектов
3. Инварианты достаточно проверять только при создании объекта
4. Нет зависимости от истории \Rightarrow нет зависимости от порядка вызова методов
5. Безопасное хранение объекта в коллекции
6. Не требуется синхронизация, так как все потоки только читают данные
*** DONE Укажите преимущества статической типизации
1. Раннее обнаружение ошибок :: Ошибки находятся на этапе компиляции, а не выполнения. Часто программа на SML или Haskell работает правильно, как только ее наконец удается скомпилировать
2. Высокая поддерживаемость больших проектов :: Изменения могут быть верифицированы компилятором, и типы являются частью документации программы, облегчая ее понимание
3. Автоматизированная обработка программ :: Например, автоматический рефакторинг, как в средах IDEA или Eclipse
4. Оптимизация кода :: Код, написанный на статически типизированном языке, проще оптимизировать, так что в среднем статически типизированный язык эффективнее динамически типизированных
** [14/16]Question 2: Basic Syntax
*** TODO Имеется класс типов: ~class C a where maxInt :: Int~. Реализуйте данный класс типов для какого-нибудь типа данных.
*** TODO Имеется класс типов: ~class C a where intGetter :: a -> Int~. Реализуйте данный класс типов для какого-нибудь типа данных.
*** DONE Как обновить ~f~ в ~data A = A { f :: Int -> Int }~
#+BEGIN_SRC haskell
changeF :: A \rightarrow Int \rightarrow Int
changeF A { f = _ } fff = A { f = fff }
#+END_SRC
*** DONE Что дает слово "*deriving*"? Что это в языке Haskell?
~deriving~ позволяет неявно определять функции стандартных ~typeclass~'ов. Детали такой неявной реализации иногда зависят от компилятора.
*** DONE Напишите реализацию ~foldr~ и ~foldl~. И нарисуйте картинку вычисления
~foldr~:
[[./images/foldr.png]]
#+BEGIN_SRC haskell
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr _ z []     = z
foldr f z (x:xs) = x `f` (foldr f z xs)
#+END_SRC
~foldl~:
[[./images/foldl.png]]
#+BEGIN_SRC haskell
foldl :: (b -> a -> b) -> b -> [a] -> b
foldl _ z []     = z
foldl f z (x:xs) = foldl (f z x) xs
#+END_SRC
*** DONE Синтаксическим сахаром для какого кода является объявление следующего типа данных: ~data MyData = A { f :: Int, g :: Int -> Double }~
#+BEGIN_SRC haskell
data MyData = A Int (Int -> Double)
#+END_SRC
*** DONE Напишите тип выражения ~flip id~.
#+BEGIN_SRC haskell
id :: a -> a
flip :: (a -> b -> c) -> b -> a -> c
-- a ≡ b -> c
flip id :: b -> (b -> c) -> c
#+END_SRC
*** DONE Напишите тип выражения ~((+) . )~
#+BEGIN_SRC haskell
(+) :: Num n => n -> n -> n
(.) :: (b -> c) -> (a -> b) -> a -> c
-- b ≡ n; c ≡ n -> n
((+) . ) :: (a -> n) -> a -> n -> n
#+END_SRC
*** DONE Напишите тип выражения ~(.) . (.)~
#+BEGIN_SRC haskell
-- left arg
(.) :: (b1 -> c1) -> (a1 -> b1) -> a1 -> c1
-- right arg
(.) :: (b2 -> c2) -> (a2 -> b2) -> a2 -> c2
-- b ≡ b1 -> c1 ≡ ((a2 -> b2) -> (a2 -> c2)); c ≡ (a1 -> b1) -> (a1 -> c1)
-- a ≡ b2 -> c2
((.) . (.)) :: (b2 -> c2) -> (a1 -> a2 -> b2) -> (a1 -> a2 -> c2)
#+END_SRC
*** DONE Имеется тип данных ~data A a = B { f :: Double }~. Укажите тип ~f~.
#+BEGIN_SRC haskell
f :: A a -> Double
#+END_SRC
*** DONE В чем отличие ~data~ от ~newtype~?
~newtype~ гарантирует, что данные будут иметь такой же вид в рантайме, как и завернутый тип. То есть Конструктор для ~newtype~ гарантированно стирается во время компиляции.
~data~ объявляет абсолютно новую структуру данных в рантайме.
*** DONE Что такое "*Currying* (каррирование)" и *функции высшего порядка*?
*Каррирование* Вычисление функции, принимающей несколько аргументов, через несколько функций, принимающих один аргумент.
Например, для функции 2-х аргументов h:(A \times B) \to C оператор каррирования \Lambda выполняет преобразование \Lambda(h):A \to (B \to C). То есть \Lambda: ((A \times B) \to C) \to (A \to (B \to C)).
#+BEGIN_SRC haskell
curry :: ((a, b) -> c) -> a -> b -> c
uncurry :: (a -> b -> c) -> (a, b) -> c
#+END_SRC
*Функции высшего порядка* Функции, принимающие в качестве аргументов другие функции или возвращающие другие функции в качестве результата.
#+BEGIN_SRC haskell
map :: (a -> b) -> [a] -> [b]
filter :: (a -> Bool) -> [a] -> [a]
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
#+END_SRC
*** DONE Напишите, что такое DatatypeContexts? Приведите пример (не из презентации)
Ограничения на параметры в объявлениях ~data~ и ~newtype~. Объявленные таким образом типы требуют выполнения ограничений при создании (/construction/) и деконструкции (/deconstruction/, \approx разбиение конструктора при паттерн-матчинге), даже если эти ограничения неиспользуются. (deprecated in Haskell 7.2)
#+BEGIN_SRC haskell
data Eq a => Foo a = Constr a

-- не можем написать функцию:
isEq :: Foo a -> Foo a -> Bool
-- должны написать:
isEq :: Eq a => Foo a -> Foo a -> Bool
isRa (Constr x) (Constr y) = x == y

-- не сработает:
getVal :: Foo a -> a
-- сработает:
getVal :: Eq a => Foo a -> a
getVal (Constr x) = x
#+END_SRC
*** DONE Напишите тип следующей функции в наиболее общем виде: ~f a = map (* a) . map (uncurry (+)) . map (\x -> (x, x))~
#+BEGIN_SRC haskell
f :: Num a => a -> [a] -> [a]
#+END_SRC
*** DONE Напишите функцию с типом, которая принимает список пар чисел и оставляет только такие, что сумма чисел в паре четная.
#+BEGIN_SRC haskell
evenPairs :: (Integral a) :: [(a, a)] -> [(a, a)]
evenPairs = filter (even . uncurry (+))
#+END_SRC
*** DONE Задан тип данных ~data Role a = A { name :: String, role :: a } | B { name :: String, roles :: [a] }~. Напишите конструкцию, синтаксическим сахаром для которой является данных Record Syntax.
#+BEGIN_SRC haskell
data Role a = A String a | B String [a]
    name :: Role a -> String
    name (A name _) = name
    name (B name _) = name

    role :: Role a -> a
    role (A _ role) = role

    roles :: Role a -> [a]
    roles (B _ roles) = roles
#+END_SRC
*** Когда стоит описывать функцию, зависящую от type класса, внутри, а когда снаружи?
Когда функция изменяет класс или переводит класс во что-то другое - лучше внутри, если хотим использовать этот класс для вычисления, то снаружи.
*** Как писать функции и операторы в префиксной и инфиксной нотации?
(:) - это префиксная нотация, : - инфиксная
map f a - префиксная, f `map` a - инфиксная
** [10/10]Question 3: Kinds
*** DONE Приведите пример типа с kind'ом ~Constraint -> *~
#+BEGIN_SRC haskell
type P a = a => Int
#+END_SRC
*** DONE Приведите пример типа с kind'ом ~(* -> Constraint) -> Constraint~
Не существует, наверное (или я нуб)
*** DONE Приведите пример типа с kind'ом ~(* -> *) -> Constraint~
~Monad, Functor, Applicative~
*** DONE Приведите пример типа с kind'ом ~(* -> Constraint) -> *~
#+BEGIN_SRC haskell
type P a = a Int => Int
#+END_SRC
*** DONE Приведите пример типа с kind'ом ~* -> Constraint~
~Num, Ord, Eq, Show~
*** Приведите пример типа с kind’ом ~(*->*)->*->*~
MaybeT
*** Приведите пример типа с kind’ом ~(* -> *) -> *~
~Monad (?)
IntComputation
Computable :: * -> (* -> *) -> *
Computable String :: (* -> *) -> *~
*** DONE Укажите kind для ~Monad~
~(* -> *) -> Constraint~
*** DONE Укажите kind следующего типа данных: ~data A f g = B (f g) (g f)~
Не существует
*** DONE Укажите kind следующего типа данных: ~data A f g = B (f g Int)~
~A :: (* -> * -> *) -> * -> *~
*** DONE Укажите kind типа ~type C p = p Int => Int~
~C :: (* -> Constraint) -> *~
*** DONE Укажите kind типа ~type C p = (p Int, p Double)~
~C :: (* -> *) -> *~
*** Укажите kind типа ~type D a = (a Int, Num Int)~
~D :: (* -> Constraint) -> Constraint~
** [13/14]Question 4: Type hierarchy
*** DONE Чему равно значение ~length (Left "hello")~ и почему?
~0~, потому что левая ветка в ~Either~ отвечает за ошибки и реализация в ~Left~
по умолчанию выдает ~0~.
*** DONE Чему равно значение ~length (Just [1..10])~ и почему?
~length~ для ~Just _~ логичным образом равен ~1~.
*** DONE Напишите type class ~Traversable~
#+BEGIN_SRC haskell
class (Functor t, Foldable t) \Rightarrow Traversable t where
    traverse :: Applicative f \Rightarrow (a \rightarrow f b) \rightarrow t a \rightarrow f (t b)
    traverse f = sequenceA . fmap f
    sequenceA :: Applicative f \Rightarrow t (f a) \rightarrow f (t a)
    sequenceA = traverse id
    mapM :: Monad m \Rightarrow (a \rightarrow m b) \rightarrow t a \rightarrow m (t b)
    mapM = traverse
    sequence :: Monad m \Rightarrow t (m a) \rightarrow m (t a)
    sequence = sequenceA
#+END_SRC
*** DONE Напишите реализацию ~Traversable~ для списка
#+BEGIN_SRC haskell
instance Traversable [] where
    traverse f = foldr consF (pure [])
      where
        consF x ys =(:) <$> f x <*> ys
#+END_SRC
*** DONE Напишите реализацию ~Traversable~ для ~Maybe~
#+BEGIN_SRC haskell
instance Traversable Maybe where
    traverse _ Nothing = pure Nothing
    traverse f (Just x) = Just <$> f x
#+END_SRC
*** DONE Напишите реализацию ~Traversable~ для ~Either~
#+BEGIN_SRC haskell
instance Traversable (Either a) where
    traverse _ (Left x) = pure (Left x)
    traverse f (Right y) = Right <$> f y
#+END_SRC
*** DONE Напишите реализацию ~Foldable~ для списка
#+BEGIN_SRC haskell
instance Foldable [] where
    foldr = List.foldr
#+END_SRC
*** DONE Напишите реализацию ~Foldable~ для ~Maybe~
#+BEGIN_SRC haskell
instance Foldable Maybe where
    foldr _ z Nothing = z
    foldr f z (Just x) = f x z
#+END_SRC
*** DONE Напишите реализацию ~Foldable~ для ~Either~
#+BEGIN_SRC haskell
instance Foldable (Either a) where
    foldMap _ (Left _) = mempty
    foldMap f (Right y) = f y
#+END_SRC
*** TODO Напишите, что делают эти расширения языка: ~TypeSynonyms, MultiParamTypeClasses, ViewPatterns, RecordsWildCards~
*** DONE Реализуйте ~traverse~ через ~sequence~.
#+BEGIN_SRC haskell
traverse f = sequenceA . fmap f
#+END_SRC
*** DONE Реализуйте ~sequence~ через ~traverse~.
#+BEGIN_SRC haskell
sequenceA = traverse id
#+END_SRC
*** DONE Укажите *minimal complete definition* для type class'а ~Foldable~
~foldr~ или ~foldMap~.
*** DONE Укажите *minimal complete definition* для type class'а ~Traversable~
~traverse~ или ~sequenceA~.
** [0/5]Question 5: Functors
*** TODO Напишите законы *функтора*
*** TODO Реализуйте функцию ~(<<$>>) :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)~
*** TODO Напишите класс типов ~Bifunctor~ и реализуйте его для пары
*** TODO Напишите класс типов ~Bifunctor~ и реализуйте его для ~Either~
*** TODO Реализуйте ~fmap~ через ~bind~
*** Реализуйте ~bind~ через ~join~ и ~fmap~
#+BEGIN_SRC haskell
>>= :: m a -> (a -> m b) -> m b
fmap :: (a -> b) -> f a -> f b
join :: m (m a) -> m a
a >>= f = join (fmap f a)
#+END_SRC
** [2/7]Question 6: Applicatives
*** TODO Напишите type class ~Applicative~ и его реализацию для ~((->) r)~
*** TODO Напишите type class ~Applicative~ и его реализацию для ~ZipList~
*** DONE Реализуйте функцию ~liftA3~
#+BEGIN_SRC haskell
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
liftA3 f a b c = fmap f a <*> b <*> c
#+END_SRC
*** DONE Реализуйте функцию ~liftAA2 :: (Applicative f, Applicative g) => (a -> b -> c) -> f (g a) -> f (g b) -> f (g c)~
#+BEGIN_SRC haskell
liftAA2 = liftA2 . liftA2
#+END_SRC
*** TODO Реализуйте функцию ~(<<*>>) :: (Applicative f, Applicative g) => f (g (a -> b)) -> f (g a) -> f (g b)~
*** TODO Реализуйте функцию ~eitherA :: (Alternative f) => f a -> f b -> f (Either a b)~
*** TODO Есть функция ~g :: a -> b~ и объект ~x :: Applicative f => f a~. Напишите два разных способа получить объект ~y :: Applicative f => f b~ из ~x~ с использованием ~g~.
*** Реализуйте Applicative для списка
#+BEGIN_SRC haskell
class Functor f => Applicative f where
    pure :: a -> f a
    <*> :: f (a -> b) -> f a -> f b
instance Applicative [] where
    pure x = [x]
    fs <*> xs = [f x | f <- fs, x <- xs]
#+END_SRC
*** Реализуйте Applicative для Either
#+BEGIN_SRC haskell
instance Applicative (Either e) where
    pure          = Right
    Left  e <*> _ = Left e
    Right f <*> r = fmap f r
#+END_SRC
*** Написать fmap с forall
#+BEGIN_SRC haskell
fmap :: forall f . forall a b . (a -> b) -> f a -> f b
#+END_SRC
** [13/16]Question 7: Monads
*** DONE Что такое монада?
Монады применяют функции, которые возвращают завернутые значения, к завернутому значению.
#+BEGIN_SRC haskell
class Monad m where   -- m :: * -> *
    return :: a -> m a                  -- return
    (>>=)  :: m a -> (a -> m b) -> m b  -- bind
    (>>)   :: m a -> m b -> m b         -- then
    m >> k = m >>= \_ -> k
(=<<) :: Monad m => (a -> m b) -> m a -> m b
f =<< x = x >>= f
infixl 1  >>, >>=
infixr 1  =<<
#+END_SRC
*** DONE Напишите не меньше пяти типов данных, являющихся монадой
1. []
2. Maybe
3. Either
4. IO
5. State
6. Identity
7. Writer
8. Reader
9. RWS
10. Cont
... ST, STM, Option, (->) a, Min
*** DONE Напишите не менее семи функций, полезных при работе с монадами
1. return
2. >>=
3. =<<
4. >>
5. liftM
6. liftM2
7. >=>
8. <=<
9. join
10. ifM
11. (||^)
*** DONE Отличие ~unsafePerformIO~ от ~unsafeInterleaveIO~?
~unsafeInterleaveIO~ дает дополнительные гарантии на порядок операций, идейно так реализовано:
#+BEGIN_SRC haskell
do
    before
    unsafeInterleaveIO side
    after
#+END_SRC
Гарантируется, что то, что в ~side~ всегда выполнится после ~before~.
~unsafePerformIO~ таких гарантий не дает.
*** DONE Напишите тип функции ~join~ и приведите несколько примеров использования
#+BEGIN_SRC haskell
join :: (Monad m) \Rightarrow m (m a) \rightarrow m a
#+END_SRC
~join [[1,2],[3,4]] === [1,2,3,4]~
~join Just (Just 5) === Just 5~
*** DONE Реализуйте ~join~ через ~bind~.
#+BEGIN_SRC haskell
join x = x >>= id
#+END_SRC
*** DONE Напишите реализацию ~Monad~ для списка
#+BEGIN_SRC haskell
instance Monad [] where
    return x = [x]
    l >>= f = concat (map f l)
#+END_SRC
*** DONE Напишите реализацию ~Monad~ для ~Maybe~
#+BEGIN_SRC haskell
data Maybe a = Nothing | Just a

instance Monad Maybe where
    return = Just
    Nothing >>= _ = Nothing
    Just a  >>= f = f a
#+END_SRC
*** DONE Напишите реализацию ~Monad~ для ~Either~
#+BEGIN_SRC haskell
instance Monad (Either a) where
    return = Right
    Left l >>= _ = Left l
    Right r >>= f = f r
#+END_SRC
*** Реализуйте Monad для ((->) r)
#+BEGIN_SRC haskell
instance Monad ((->) r) where
    f >>= k = \ r -> k (f r) r
#+END_SRC
*** Напишите реализацию ~Monoid для Maybe~
#+BEGIN_SRC haskell
instance Monoid a => Monoid (Maybe a) where
    mempty = Nothing
    Nothing `mappend` m = m
    m `mappend` Nothing = m
    Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)
#+END_SRC
*** Напишите реализацию Monoid для (->)
#+BEGIN_SRC haskell
instance Monoid b => Monoid (a -> b) where
        mempty _ = mempty
        mappend f g x = f x `mappend` g x
mappend :: (a->b) -> (a->b) -> a->b          <<<<<====== ???????????
#+END_SRC
*** DONE Напишите определение типа данных ~Writer~ и его ~instance Monad~
#+BEGIN_SRC haskell
newtype Writer w a = Writer { runWriter :: (a, w) } -- a - значение, w - лог

instance Monoid m => Monad (Writer w) where
    return a = Writer (a, mempty)
    Writer (x, v) >>= f = let Writer (y, v') = f x
                          in Writer (y, v `mappend` v')
#+END_SRC
*** DONE Напишите определение типа данных ~Reader~ и его ~instance Monad~
#+BEGIN_SRC haskell
newtype Reader e a = Reader { runReader :: e \rightarrow a }

instance Monad (Reader e) where
    return a = Reader $ \_ \rightarrow a
    m >>= f = Reader $ \r \rightarrow runReader (f $ runReader m r)  r
#+END_SRC
*** DONE Напишите определение типа данных ~State~ и его ~instance Monad~
#+BEGIN_SRC haskell
newtype State s a = State { runState :: s \rightarrow (a, s) }

instance Monad (State s) where
    return a = State $ \s \rightarrow (a, s)
    oldState >>= f = State $ \s \rightarrow let (a, newState) = runState oldState s
                                  in runState (f a) newState
#+END_SRC
*** DONE Напишите определение типа данных ~Cont~ и его ~instance Monad~
#+BEGIN_SRC haskell
newtype Cont r a = Cont { runCont :: (a \rightarrow r) \rightarrow r }

instance Monad (Cont r) where
    return a = Cont ($ a)
    Cont arr >>= f = Cont $ \br \rightarrow arr $ \a \rightarrow runCont (f a) br
#+END_SRC
*** TODO Что такое ~IO~? Как теоретически это реализовано?
*** TODO Покажите, синтаксическим сахаром для чего является ~do~-нотация (включая ~let~).
*** TODO Напишите тип ~(>=>)~ и смысл этого оператора.
** [7/7]Question 8: Trans
*** DONE Напишите класс типов ~MonadTrans~ и реализуйте его для ~StateT~
#+BEGIN_SRC haskell
class MonadTrans t where
    lift :: Monad m \Rightarrow m a \rightarrow t m a

newtype StateT s m a = StateT { runStateT :: (s \rightarrow m (a, s)) }

instance MonadTrans (StateT s) where
    lift c = StateT $ \s \rightarrow c >>= (\x \rightarrow return (x, s))
#+END_SRC
*** DONE Напишите класс типов ~MonadTrans~ и реализуйте его для ~WriterT~
#+BEGIN_SRC haskell
class MonadTrans t where
    lift :: Monad m \Rightarrow m a \rightarrow t m a

newtype WriterT w m a = WriterT { runWriterT :: m (a, w) }

instance Monoid m \Rightarrow MonadTrans (WriterT w) where
    lift m = WriterT $ do
                       a \leftarrow m
                       return (a, mempty)
#+END_SRC
*** DONE Напишите класс типов ~MonadTrans~ и реализуйте его для ~MaybeT~
#+BEGIN_SRC haskell
class MonadTrans t where
    lift :: Monad m \Rightarrow m a \rightarrow t m a

newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }

instance MonadTrans MaybeT where
    lift m = MaybeT $ do
                      a \leftarrow m
                      return $ Just a
#+END_SRC
*** DONE Напишите класс типов ~MonadTrans~ и реализуйте его для ~ReaderT~
#+BEGIN_SRC haskell
class MonadTrans t where
    lift :: Monad m \Rightarrow m a \rightarrow t m a

newtype ReaderT e m a = ReaderT { runReaderT :: e \rightarrow m a }

instance MonadTrans (ReaderT e) where
    lift m = ReaderT (const m)
#+END_SRC
*** DONE Напишите тип ~StateT~ и то, как определен ~State~ через ~StateT~
#+BEGIN_SRC haskell
newtype StateT s m a = StateT { runStateT :: (s \rightarrow m (a, s)) }

type State s = StateT s Identity
#+END_SRC
*** DONE Напишите тип ~MaybeT~ и реализуйте его инстанс ~Monad~
#+BEGIN_SRC haskell
newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }

instance Monad m \Rightarrow Monad (MaybeT m) where
    return x = MaybeT $ return $ Just x
    MaybeT action >>= f = MaybeT $ do
                                   result \leftarrow action
                                   case result of
                                       Nothing \rightarrow return Nothing
                                       Just x \rightarrow runMaybeT $ f x
#+END_SRC
*** DONE Нарисуйте табличку отличий обычных типов и их трансформеров для известных вам трансформеров
| Base monad | Transformer | Original type | Combined type   |
|------------+-------------+---------------+-----------------|
| Maybe      | MaybeT      | Maybe a       | m (Maybe a)     |
| Either     | EitherT     | Either a b    | m (Either a b)  |
| Writer     | WriterT     | (a, w)        | m (a, w)        |
| Reader     | ReaderT     | r \rightarrow a         | r \rightarrow m a         |
| State      | StateT      | s \rightarrow (a, s)    | s \rightarrow m (a, s)    |
| Cont       | ContT       | (a \rightarrow r) \rightarrow r   | (a \rightarrow m r) \rightarrow m r |
*** Разница между unsafeIO и InterLeaveIO
** [0/10]Question 9: Strict Lazy
*** TODO Что такое *irrefutable patterns* и зачем они нужны?
*** TODO Что такое *Stream Fusion* и зачем он нужен?
*** TODO Напишите, что значит тип ~ST~ и напишите основные функции по работе с ним
*** TODO Что такое ~BangPatterns~? Когда их нужно использовать?
*** TODO Укажите, что делает ~deepseq~ и как.
*** TODO В чем разница между ~seq~ и ~deepseq~?
*** TODO В чем разница между ~seq~ и ~BangPatterns~?
*** TODO Что такое ~STRef~ и в чем отличие от ~IORef~?
*** TODO Что такое *Deforestation*?
*** TODO Чем плохо использовать ~IORef~ и ~IOArray~? Зачем нужны ~STRef~ и ~STArray~?
*** seq - что и зачем это
x seq y означает, что когда y рассчитан до WHNF, x тоже просчитывается до whnf.
Нужно для для того, чтобы сделать x strict
seq x b behaves essentially like if x == 0 then b else b – unconditionally equal to b, but forcing x along the way
*** WHNF. пример в ней и не в ней
An expression is in weak head normal form (WHNF), if it is either:
- a constructor (eventually applied to arguments) like True, Just (square 42) or (:) 1
- a built-in function applied to too few arguments (perhaps none) like (+) 2 or sqrt.
- or a lambda abstraction \x -> expression.
An expression in weak head normal form has been evaluated to the outermost data constructor or lambda abstraction (the head). Sub-expressions may or may not have been evaluated. Therefore, every normal form expression is also in weak head normal form, though the opposite does not hold in general
WHNF: \x -> x + 2
NOT WHNF: (\x -> x + 2) 3 
** [0/4]Question 10: TemplateHaskell
*** TODO Как можно посмотреть *AST-дерево* для выражения в Haskell?
*** TODO Напишите не меньше трех применений *TemplateHaskell*
*** TODO Что такое ~Q~ в типах функций Template Haskell?
*** TODO В чем разница между ~[| |]~ и ~$()~?
*** 4 применения темплейт хаскеля
- Писать функции n аргументов
- Генерить автоматом инстансы
- Что-то высчитывать во время компиляции, тип один раз и навсегда.
- Парсить всякие структуры типа json
- Генерировать автоматом линзы
** [3/10]Question 11: Lenses
*** Зачем нужны линзы
Чтобы в сложных структурах(записях) удобно доставать и изменять значения.
*** TODO Что такое изоморфизм (~Iso~)?
*** TODO Чем линзы отличаются от призм?
*** DONE Напишите тип ~Iso~
#+BEGIN_SRC haskell
type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)
#+END_SRC
*** DONE Напишите тип функции ~from~ для ~Iso~
#+BEGIN_SRC haskell
from :: AnIso s t a b -> Iso b a t s
#+END_SRC
*** DONE Напишите тип функции ~iso~
#+BEGIN_SRC haskell
iso :: (s -> a) -> (b -> t) -> Iso s t a b
#+END_SRC
*** TODO Напишите реализацию ~over~
*** TODO Реализуйте ~set~ через ~over~
*** TODO Реализуйте ~over~ через ~view~ и ~set~.
*** TODO Напишите функцию ~lens~, которая принимает геттер и сеттер и возвращает линзу
*** TODO Укажите операторные обозначений функций ~view~, ~set~, ~over~. Есть ли отличие в типах функций и их операторных выражений?
*** Реализация view
Не понятно к чему это, ну тип view' :: obj -> field
Как мы его делаем, есть поле car, ну и пишем car Person
** [0/8]Question 12: Threads
*** TODO Что такое ~STM~ (коротко), что позволяет делать и какие есть функции по работе с ним?
*** TODO В чем отличие Haskell потоков от, например, потоков в Java?
*** TODO Что такое ~Strategy~? Перечислите несколько стратегий и реализуйте некоторые. Зачем они нужны?
*** TODO Как в Haskell обстоят дела с *DeadLock*'ами?
*** TODO Что такое *RTS*?
*** TODO Укажите несколько полезных опций *RTS*
*** TODO Опишите, что такое ~MVar~, зачем он может быть нужен и несколько функций по работе с этим объектом.
*** TODO Что делает ~forkIO~? Чем он отличается от ~forkFinally~?
*** Как в хаскеле реализована concurency
Par, Strategy, forkIO, MVar, STM, Async
*** Что такое spark и его флаги
Мини тред, занятый одним вычислением, соответственно легковесный и их можно завести очень много
converted - useful work
overflowed - sparks generated after spark pool limit achieved
dud - already evaluated at the moment of applying `rpar`
GC'd - unused and thrown away (ignored) => garbage collector
fizzled - was unevluated at the time it was sparked but was later evaluated independently by the program
** [5/5]Question 13: forall
*** DONE Напишите, как иметь список объектов разных функторов, внутри каждого из которых значения одинакового типа, чтобы иметь возможность применить функции из этого значения в другое?
CLOSED: [2017-03-14 вт 01:03]
#+BEGIN_SRC haskell
data FunctorBox a = forall f . Functor f => FB (f a)
FB :: forall {a} {f :: * -> *} . Functor f => f a -> FunctorBox a -- as ghci sees it

fmapFB :: forall t a . (t -> a) -> FunctorBox t -> FunctorBox a
fmapFB f = \(FB a) -> FB (f <$> a)
#+END_SRC
*** DONE Зачем нужно расширение ~ExistentialQuantification~?
Для того, чтобы работать со значениями разных типов, но обладающими каким-то свойством (например, они одного класса), одинаково. Например, чтобы иметь возможность складывать такие значения в лист, получая тем самым гетерогенный лист, спрятав значения в некоторую "коробку" (/type hider/)
*** DONE Зачем нужно расширение языка ~-XExplicitForall~?
Чтобы явно аннотировать типы с использованием ~forall~
*** DONE В чем разница между ~-XRank2Types~ и ~-XRankNTypes~? Зачем нужны оба?
~-XRank2Types~ разрешает полиморфные типы ранга 2, ~-XRankNTypes~ разрешает полиморфные типы любого ранга.
В системах с полиморфными типами ранга 2 задача вывода типов разрешима, если же ранг > 2, то задача становится неразрешимо и возникает необходимость явной аннотации типов. С этим и связана необходимость разделения этих расширений языка.
*** DONE Зачем нужно расширение языка ~-XScopedTypeVariables~ и как оно взаимодействует с ~forall~?
Позволяет указывать, что переменные типа из сигнатуры распространяются на тело функции. Чтобы это работало, надо использовать ~forall~ в сигнатуре:
#+BEGIN_SRC haskell
  {-# LANGUAGE ScopedTypeVariables #-}
  import Data.List

  main = putStrLn "No errors."

  -- show
  myFunction :: forall a. Ord a => [a] -> [(a, a)]
  myFunction inputList = zip sortedList nubbedList
      where sortedList :: [a]
            sortedList = sort inputList
            nubbedList :: [a]
            nubbedList = nub inputList
  -- /show
#+END_SRC
** [4/5]Question 14: Advanced types
*** DONE Что такое *typed holes* и зачем они нужны?
С их помощью можно спросить у компилятора, какого типа должно быть твое что-то.
#+BEGIN_SRC haskell
  mfold :: [Maybe a] -> [Either a b]
  mfold = foldr _f _z

  > Found hole ‘_f’ with type: Maybe a -> [Either a b] -> [Either a b]
  > Found hole ‘_z’ with type: [Either a b]
#+END_SRC
*** DONE Зачем нужно расширение языка ~-XTypeApplications~?
Позволяет задавать явные аргументы типов полиморфной функции, например ~map @Int @Bool isEven xs~. Решает проблему show/read, потому что мы явно задаем типы и все тайпчекается.
#+BEGIN_SRC haskell
  answer_read = show (read @Int "3") -- "3" :: String
  answer_show = show @Integer (read "5") -- "5" :: String
  answer_showread = show @Int (read @Int "7") -- "7" :: String
#+END_SRC
*** DONE Зачем нужно расширение языка ~-XPartialSignatures~?
Аналог typed holes для сигнатур функций:
#+BEGIN_SRC haskell
  arbitCs :: _ => a -> String
  arbitCs x = show (succ x) ++ show (x == x)
  Main.hs:6:12: warning: [-Wpartial-type-signatures]
      Found constraint wildcard ‘_’ standing for ‘(Show a, Eq a, Enum a)’
      In the type signature:
        arbitCs :: _ => a -> String
#+END_SRC
*** TODO Можно ли создать следующий тип данных в Haskell: ~data a : > b = (a -> b) : > (b -> a)~?
*** DONE Что такое *Functional Dependencies*? Назовите какой-нибудь известный вам type class, в котором присутствуют функциональные зависимости.
Функциональные зависимости используются для ограничения параметров тайпклассов. Они позволяют объявить, что в тайпклассе с несколькими параметрами один из параметров можно *однозначно!* определить по другим.
#+BEGIN_SRC haskell
class Mult a b c | a b -> c where
  (*) :: a -> b -> c
#+END_SRC
Классический (и единственный) пример использования - перемножение матриц/векторов/скаляров, тайпкласс указан выше.
*** Пример функции 2-го ранга
#+BEGIN_SRC haskell
Rank 0: Int
Rank 1: forall a . a -> Int
Rank 2: (forall a . a -> Int) -> Int
Rank 3: ((forall a . a -> Int) -> Int) -> Int
foo :: (forall a. a -> a) -> (Char,Bool)
  foo f = (f 'c', f True)
  #+END_SRC
*** Что делает -XDataKinds
Заставляет создавать компилятор кайнды для нашей даты
Промоутит простые типы до кайндов
*** GADT
Generalized algebraic datatypes или просто ГАДы
Generalized algebraic datatypes, or simply GADTs, are a generalization of the algebraic data types that you are familiar with. Basically, they allow you to explicitly write down the types of the constructors.
** [0/11]Question 15: Comonads
*** TODO Напишите пример использования *комонад*
*** TODO Напишите, какие комонады двойственны монадам ~Reader, Writer, State~
*** TODO Напишите, какие комонады двойственны монадам ~Traced, Store, Env~
*** TODO Напишите комонаду ~Stream~ и инстанс ~Comonad~ для нее.
*** TODO Напишите комонаду ~Env~ и инстанс ~Comonad~ для нее.
*** TODO Напишите комонаду ~Store~ и инстанс ~Comonad~ для нее.
*** TODO Напишите комонаду ~Traced~ и инстанс ~Comonad~ для нее.
*** TODO Реализуйте ~instance Comonad~ для обычного ~Zipper~
*** TODO ~IO~ использует абстракцию монад, какой аналог есть в мире комонад?
*** TODO Напишите класс ~ComonadTrans~
*** TODO Как можно было бы сделать ~codo~ нотацию для комонад? И что бы происходило в этом синтаксическом сахаре?
*** Extend для comonad
#+BEGIN_SRC haskell
class Functor w => Comonad w where
    extract   :: w a -> a
    (<<=)     :: (w a -> b) -> w a -> w b  -- extend
    duplicate :: w a -> w (w a)
extend f  = fmap f . duplicate
duplicate = extend id
fmap f    = extend (f . extract)

data [a] = [] | a : [a]
data ListZipper a = LZ [a] a [a]
instance Functor ListZipper where
    fmap f (LZ ls x rs) = LZ (map f ls) (f x) (map f rs)
extract :: ListZipper a -> a
extract (LZ _ x _) = x
#+END_SRC
*** zipper
Такая штуковина, которая работает с бесконечными структурами, и ползает по ним с пом. курсора, помогает считать значения, зависящие от соседей
#+BEGIN_SRC haskell
data [a] = [] | a : [a]
data ListZipper a = LZ [a] a [a]
listLeft, listRight :: ListZipper a -> ListZipper a
-- Сдвиг вправо и влево
listLeft  (LZ (a:as) x bs) = LZ as a (x:bs)
listRight (LZ as x (b:bs)) = LZ (x:as) b bs
#+END_SRC
** [0/8]Question 16: Idris
*** TODO Реализуйте функцию ~take~ для вектора на Idris
*** TODO Реализуйте функцию ~filter~ для вектора на Idris
*** TODO Реализуйте функцию ~head~ для списка на Idris, которая компилируется только с гарантированно непустыми списками.
*** TODO Напишите тип "*зависимая пара*" на Idris
*** TODO Что такое ~[| |]~-идиома в Idris?
*** TODO Что такое ~!~-идиома в Idris?
*** TODO Что такое ~_|_-eliminator~? Зачем это надо?
*** TODO Что такое "*тотальность*" и какие преимущества она дает?
*** Какие парадигмы использует Irdis
Totality
Strict evalution
Theorem proving
DSL
Extensible effects
*** Зависимые типы в idris и зачем они нужны
Зависимый тип в информатике и логике — тип, который зависит от некоторого значения.
К примеру, тип, описывающий n-кортежи действительных чисел является зависимым, так как он «зависит» от величины n.
типы функций тогда могут принимать вид «функция, принимающая сообщение, подписанное некоторым пользователем, и возвращающая данные этого пользователя», вместо более распространённого «функция, принимающая сообщение и возвращающая данные пользователя», что ведёт к намного более точным спецификациям. Более того, это даёт возможность, так сказать, перейти от подлежащих к сказуемым, использовать принцип «высказывания как типы»: «5 больше 3», «неверно, что 5 больше 3», «7 является простым числом», «Василий получил 2 сообщения».
*** Отличие irdis от разных языков
Идрис сочетает в себе особенности относительно мейнстримовых языков функционального программирования с функциями, заимствованных из систем автоматического доказательства теорем, фактически размывает границу между этими двумя видами программного обеспечения.
*** Пример кода на irdis
(++) : Vect n a -> Vect m a -> Vect (n + m) a
(++) Nil       ys = ys
(++) (x :: xs) ys = x :: xs ++ ys
